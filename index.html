<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <title>Evolving Color Life - Stagnation Version</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #111;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            -webkit-text-size-adjust: 100%; /* Prevent text size adjustment on mobile */
        }
        
        * {
            box-sizing: border-box;
        }
        
        h1 {
            margin: 0 0 20px 0;
            font-size: 24px;
            color: #fff;
        }
        
        #canvas {
            border: 2px solid #333;
            cursor: crosshair;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none; /* Prevent default touch behaviors like scrolling */
            -webkit-user-select: none; /* Prevent text selection on touch */
            user-select: none;
        }
        
        #canvas.eraser-cursor {
            cursor: none; /* Hide default cursor when using eraser */
        }
        
        /* Selection box styles */
        .selection-box {
            position: absolute;
            border: 2px dashed #fff;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        .save-button {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #2a6a2a;
            border: 2px solid #fff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 9px;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            font-weight: bold;
            pointer-events: auto;
        }
        
        .save-button:hover {
            background: #3a8a3a;
            transform: scale(1.1);
        }
        
        /* Load modal styles */
        .load-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            align-items: center;
            justify-content: center;
        }
        
        .load-modal-content {
            background-color: #1a1a1a;
            padding: 20px;
            border: 2px solid #444;
            border-radius: 10px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        
        .load-modal-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .saved-pattern-item {
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .saved-pattern-item:hover {
            background: #3a3a3a;
            border-color: #666;
            transform: scale(1.02);
        }
        
        .pattern-info {
            flex: 1;
        }
        
        .pattern-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .pattern-size {
            font-size: 11px;
            color: #aaa;
        }
        
        .pattern-delete {
            background: #6a2a2a;
            color: #fff;
            border: none;
            border-radius: 3px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 11px;
            margin-left: 10px;
        }
        
        .pattern-delete:hover {
            background: #8a3a3a;
        }
        
        .close-modal {
            background: #4a4a4a;
            color: #fff;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
        }
        
        .close-modal:hover {
            background: #5a5a5a;
        }
        
        .no-patterns-message {
            text-align: center;
            color: #888;
            padding: 20px;
            font-style: italic;
        }
        
        .rule-set-section {
            margin-bottom: 15px;
            border: 1px solid #444;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .rule-set-header {
            background: #2a2a2a;
            padding: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
            transition: background 0.2s;
        }
        
        .rule-set-header:hover {
            background: #3a3a3a;
        }
        
        .rule-set-title {
            font-weight: bold;
            font-size: 14px;
            flex: 1;
        }
        
        .rule-set-info {
            font-size: 11px;
            color: #888;
            margin-top: 3px;
        }
        
        .rule-set-count {
            background: #4a4a4a;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            margin-left: 10px;
        }
        
        .rule-set-actions {
            display: flex;
            gap: 5px;
            margin-left: 10px;
        }
        
        .rule-set-action-btn {
            background: #4a4a4a;
            color: #fff;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 10px;
        }
        
        .rule-set-action-btn:hover {
            background: #5a5a5a;
        }
        
        .rule-set-patterns {
            display: none;
            background: #1a1a1a;
        }
        
        .rule-set-patterns.expanded {
            display: block;
        }
        
        .expand-icon {
            font-size: 12px;
            margin-right: 8px;
            transition: transform 0.2s;
        }
        
        .expand-icon.expanded {
            transform: rotate(90deg);
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }
        
        .color-palette {
            margin: 15px 0;
            display: flex;
            gap: 6px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .color-swatch {
            width: 35px;
            height: 35px;
            border: 3px solid #444;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }
        
        .color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        
        .color-swatch.active {
            border: 3px solid #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.6);
            transform: scale(1.15);
        }
        
        .tool-button {
            width: 35px;
            height: 35px;
            border: 3px solid #444;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            flex-shrink: 0;
            background: #2a2a2a;
            color: #fff;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            min-height: unset;
        }
        
        .tool-button:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            background: #3a3a3a;
        }
        
        .tool-button.active {
            border: 3px solid #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.6);
            transform: scale(1.15);
            background: #4a4a4a;
        }
        
        button {
            padding: 10px 20px;
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
            min-height: 44px; /* iOS minimum recommended touch target */
        }
        
        button:hover {
            background: #3a3a3a;
        }
        
        button:active {
            background: #1a1a1a;
        }
        
        button.active {
            background: #4a4a4a;
            border-color: #666;
        }
        
        .info {
            margin: 20px 0;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            max-width: 800px;
            line-height: 1.6;
        }
        
        .canvas-info {
            margin-top: 5px;
            font-size: 11px;
            color: #fff;
            text-align: left;
        }
        
        .color-button {
            padding: 6px 10px;
            background: #2a2a2a;
            color: #fff;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            font-family: 'Segoe UI', system-ui, sans-serif;
            min-width: 190px; /* Fixed minimum width to prevent shifting */
            justify-content: flex-start;
            white-space: nowrap;
        }
        
        .color-button:hover {
            background: #3a3a3a;
            border-color: #666;
        }
        
        .color-button.active {
            background: #4a4a4a;
            border-color: #888;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        
        select, input[type="range"] {
            padding: 5px;
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
        }
        
        select {
            min-width: 80px;
            font-size: 14px;
        }
        
        select option {
            background: #2a2a2a;
            color: #fff;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .rules-section {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            max-width: 800px;
        }
        
        .rule-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            gap: 8px;
        }
        
        .rule-title {
            font-weight: bold;
            font-size: 14px;
            color: #fff;
            margin: 0;
        }
        
        .rule-sliders {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .rule-sliders .slider-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .rule-sliders input[type="range"] {
            width: 100px;
        }
        
        .capped-highlight {
            color: #ff6b6b !important;
            font-weight: bold;
            animation: pulse 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        /* Mobile-specific styles */
        @media (max-width: 480px) {
            .color-swatch, .tool-button {
                width: 30px;
                height: 30px;
                border: 2px solid #444;
            }
            
            .color-swatch.active, .tool-button.active {
                border: 2px solid #fff;
            }
            
            .color-palette {
                gap: 4px;
            }
        }
    </style>
</head>
<body>
    <h1>-The Game of Life Pro-</h1>
    
    <canvas id="canvas"></canvas>
    <div class="canvas-info">
        Generation: <span id="generation">0</span> | Zoom: <span id="zoomDisplay">1.00x</span> | Tools/Settings ‚¨áÔ∏è
    </div>
    
    <!-- Color Palette Row -->
    <div class="color-palette">
        <button class="color-swatch active" data-color="1" id="colorWhite" style="background: white; border: 2px solid #666;"></button>
        <button class="color-swatch" data-color="2" id="colorRed" style="background: #ff0000;"></button>
        <button class="color-swatch" data-color="3" id="colorOrange" style="background: #ff8800;"></button>
        <button class="color-swatch" data-color="4" id="colorYellow" style="background: #ffff00;"></button>
        <button class="color-swatch" data-color="5" id="colorGreen" style="background: #00ff00;"></button>
        <button class="color-swatch" data-color="6" id="colorCyan" style="background: #00ffff;"></button>
        <button class="color-swatch" data-color="7" id="colorBlue" style="background: #0088ff;"></button>
        <button class="color-swatch" data-color="8" id="colorPurple" style="background: #8800ff;"></button>
        <button class="color-swatch" data-color="9" id="colorMagenta" style="background: #ff00ff;"></button>
        <button class="tool-button" id="lineToolButton" title="Line Tool">‚ï±</button>
        <button class="tool-button" id="rectangleToolButton" title="Rectangle Tool">‚ñ¢</button>
        <button class="tool-button" id="ovalToolButton" title="Oval Tool">‚¨≠</button>
        <button class="tool-button" id="randomButton" title="Random">üé≤</button>
        <button class="tool-button" id="eraserButton" title="Eraser">üóë</button>
        <button class="tool-button" id="selectButton" title="Select">‚¨ö</button>
        <button class="tool-button" id="pasteButton" title="Paste">üìã</button>
        <button class="tool-button" id="loadPatternButton" title="Load Pattern">üìÇ</button>
    </div>
    
    <!-- Load Modal -->
    <div id="loadModal" class="load-modal">
        <div class="load-modal-content">
            <div class="load-modal-title">Saved Patterns</div>
            <div id="savedPatternsList"></div>
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="close-modal" style="flex: 1;" id="exportAllButton">Export All</button>
                <button class="close-modal" style="flex: 1;" id="importButton">Import</button>
                <button class="close-modal" style="flex: 1;" id="closeModal">Close</button>
            </div>
        </div>
    </div>
    <input type="file" id="importFileInput" accept=".json" style="display: none;">
    
    <!-- Row 1: Play/Pause, Step, Clear, Zoom -->
    <div class="controls">
        <button id="playPause">‚ñ∂ Play</button>
        <button id="step">Step</button>
        <button id="clear">Clear</button>
        <button id="zoomButton">Zoom: OFF</button>
    </div>
    
    <!-- Row 2: Speed, Neighbors Fight, Moving Cells -->
    <div class="controls">
        <div class="slider-container">
            <label>Speed:</label>
            <input type="range" id="speed" min="1" max="30" value="20">
            <span id="speedValue">20</span>
        </div>
        <button id="toggleNeighborsFight" class="active">Neighbors Fight: ON</button>
        <button id="toggleMovingCells" class="active">Moving Cells: ON</button>
    </div>
    
    <!-- Row 3: Color Expansion Slider -->
    <div class="controls">
        <div class="slider-container">
            <label>Color Expansion (every 1-300 steps):</label>
            <input type="range" id="colorExpansionRate" min="1" max="300" value="100">
            <span id="colorExpansionValue">100</span>
        </div>
    </div>
    
    <!-- Row 4: Custom Canvas Settings -->
    <div class="controls">
        <label>Canvas Size (desktop only):</label>
        <div class="slider-container">
            <label>Width:</label>
            <select id="canvasWidth">
                <option value="50">50</option>
                <option value="75">75</option>
                <option value="100">100</option>
                <option value="150">150</option>
                <option value="200" selected>200</option>
                <option value="250">250</option>
                <option value="300">300</option>
                <option value="400">400</option>
                <option value="500">500</option>
            </select>
        </div>
        <div class="slider-container">
            <label>Height:</label>
            <select id="canvasHeight">
                <option value="50">50</option>
                <option value="75">75</option>
                <option value="100">100</option>
                <option value="150" selected>150</option>
                <option value="175">175</option>
                <option value="200">200</option>
                <option value="250">250</option>
                <option value="300">300</option>
                <option value="400">400</option>
                <option value="500">500</option>
            </select>
        </div>
        <button id="applyCanvasSize">Apply Size</button>
    </div>
    
    <!-- Cellular Automaton Rules Section -->
    <div class="controls">
        <label>Cellular Automaton Rules:</label>
        <button class="tool-button" id="saveButton" title="Save Game">üíæ</button>
        <button class="tool-button" id="loadButton" title="Load Game">üìÇ</button>
    </div>
    
    <div class="rules-section">
        <!-- Birth Rule -->
        <div class="rule-group">
            <div class="rule-title">Birth (neighbor count):</div>
            <div class="rule-sliders">
                <div class="slider-container">
                    <label>Min:</label>
                    <input type="range" id="birthMin" min="0" max="8" value="3">
                    <span id="birthMinValue">3</span>
                </div>
                <div class="slider-container">
                    <label>Max:</label>
                    <input type="range" id="birthMax" min="0" max="8" value="3">
                    <span id="birthMaxValue">3</span>
                </div>
            </div>
        </div>
        
        <!-- Survival Rule -->
        <div class="rule-group">
            <div class="rule-title">Survival (neighbor count):</div>
            <div class="rule-sliders">
                <div class="slider-container">
                    <label>Min:</label>
                    <input type="range" id="survivalMin" min="0" max="8" value="2">
                    <span id="survivalMinValue">2</span>
                </div>
                <div class="slider-container">
                    <label>Max:</label>
                    <input type="range" id="survivalMax" min="0" max="8" value="3">
                    <span id="survivalMaxValue">3</span>
                </div>
            </div>
        </div>
        
        <!-- Evolution Rule -->
        <div class="rule-group">
            <div class="rule-title">Color Evolution (neighbor count):</div>
            <div class="rule-sliders">
                <div class="slider-container">
                    <label>Min:</label>
                    <input type="range" id="evolutionMin" min="1" max="8" value="4">
                    <span id="evolutionMinValue">4</span>
                </div>
                <div class="slider-container">
                    <label>Max:</label>
                    <input type="range" id="evolutionMax" min="1" max="8" value="4">
                    <span id="evolutionMaxValue">4</span>
                </div>
            </div>
        </div>
        
        <!-- Death Rule -->
        <div class="rule-group">
            <div class="rule-title">Overpopulation Death (neighbor limit):</div>
            <div class="rule-sliders">
                <div class="slider-container">
                    <label>At:</label>
                    <input type="range" id="deathMin" min="1" max="8" value="5">
                    <span id="deathMinValue">5</span>
                    <span style="margin-left: 5px;">+ neighbors</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button id="resetRulesToDefault">Reset Rules to Default</button>
    </div>
    
    <div class="info">
        <h3>Game Rules:</h3>
        <ul>
            <li><strong>Birth:</strong> Empty cells with 3 neighbors of a color are born as that color (default: 3-3, adjustable)</li>
            <li><strong>Evolution:</strong> Cells with 4 neighbors evolve to next color (default: 4-4, adjustable). <em>Evolution is checked FIRST, allowing overlap with survival range for dynamic color changes</em></li>
            <li><strong>Survival:</strong> Cells with 2-3 neighbors survive (default: 2-3, adjustable). Only applies if evolution doesn't trigger</li>
            <li><strong>Death:</strong> Cells die with &lt;2 neighbors (isolation) or 5+ neighbors (overpopulation, default: 5+, adjustable)</li>
            <li><strong>Magenta Special:</strong> Magenta cells in evolution range spawn moving white spore then die (with Moving Cells ON) or evolve to white (OFF)</li>
            <li><strong>Color Expansion Rate:</strong> Controls stagnation threshold (1-300 generations, default: 100). Affects both Moving Cells spawning and Neighbors Fight conversion speed. Lower = faster action, higher = more stability</li>
            <li><strong>Moving Cells (Toggleable):</strong> When ON, stagnant cells (3+ same-color neighbors unchanged for Color Expansion Rate) spawn moving cells. Moving cells travel outward (70% straight/30% turn), pass through other movers, and after 4+ frames: stop on same color or convert entire groups of different colors</li>
            <li><strong>Neighbors Fight (Toggleable):</strong> When ON, stagnant cells of a higher-color will convert adjacent lower-colored neighbors. This occurs based on the Color Expansion Rate (1-300 steps). This can break stagnation and create color battles or territory expansion</li>
            <li><strong>Color Hierarchy:</strong> White ‚Üí Red ‚Üí Orange ‚Üí Yellow ‚Üí Green ‚Üí Cyan ‚Üí Blue ‚Üí Purple ‚Üí Magenta ‚Üí (spawns White spore)</li>
        </ul>
        <h3>Drawing Tools:</h3>
        <ul>
            <li><strong>Color Selection:</strong> Click any color swatch to select a drawing color, then click/drag on canvas to draw cells</li>
            <li><strong>Eraser (üóë):</strong> Click to activate/deactivate: 25√ó25 ‚Üí OFF. Red circle shows eraser size and fills when actively erasing</li>
            <li><strong>Line Tool (‚ï±):</strong> Click start point, move mouse (red preview line), click end point to draw straight line</li>
            <li><strong>Rectangle Tool (‚ñ¢):</strong> Click corner, move mouse (red preview box), click opposite corner to draw rectangle outline</li>
            <li><strong>Oval Tool (‚¨≠):</strong> Click corner, move mouse (red preview ellipse), click opposite corner to draw oval outline</li>
            <li><strong>Select Tool (‚¨ö):</strong> Click two points on canvas to select a rectangular area. Selection is automatically copied. Click and drag anywhere within the selection box to move the cells to a new position. Save button (üíæ) appears in bottom-right of selection box (desktop only)</li>
            <li><strong>Paste Tool (üìã):</strong> After selecting/copying or loading a saved pattern, click Paste then click anywhere on canvas to place the pattern</li>
            <li><strong>Load Pattern (üìÇ, desktop only):</strong> Opens saved patterns library organized by rule sets. Click any pattern to load it for pasting</li>
            <li><strong>Random (üé≤):</strong> Click to fill canvas with random cells in the currently selected color</li>
            <li><strong>Zoom:</strong> Cycles through OFF ‚Üí IN (click to zoom in) ‚Üí OUT (click to zoom out) ‚Üí OFF. Auto-limited to prevent black space based on canvas size</li>
        </ul>
        <h3>Pattern Management (Desktop Only):</h3>
        <ul>
            <li><strong>Rule Set Organization:</strong> Patterns are automatically organized into rule sets based on your current game rules (Birth, Survival, Evolution, Death, Color Expansion, Neighbors Fight, Moving Cells). When you save a pattern with new rules, you'll be prompted to name a new rule set</li>
            <li><strong>Save Pattern:</strong> Use Select Tool to select an area, then click the green üíæ button in bottom-right of selection box. If your current rules match an existing rule set, the pattern is saved there automatically. If rules are different, you'll name a new rule set first, then name the pattern</li>
            <li><strong>Load Pattern:</strong> Click the üìÇ Load Pattern button to view all rule sets and their patterns. Rule sets appear as collapsible sections showing rule details and pattern count. Click any pattern to load it into paste mode</li>
            <li><strong>Export/Import:</strong> Export individual rule sets or all rule sets as JSON files. Import previously exported files to restore or share your pattern libraries. Handles name collisions automatically</li>
            <li><strong>Delete:</strong> Delete individual patterns or entire rule sets with all their patterns from the Load Pattern dialog</li>
        </ul>
        <h3>Game Controls:</h3>
        <ul>
            <li><strong>Play/Pause (‚ñ∂):</strong> Start or pause the simulation</li>
            <li><strong>Step:</strong> Advance exactly one generation (useful for examining patterns closely)</li>
            <li><strong>Clear:</strong> Erase all cells from the canvas</li>
            <li><strong>Speed Slider:</strong> Adjust simulation speed from 1 (slowest) to 30 (fastest) generations per second</li>
            <li><strong>Canvas Size:</strong> Custom width/height with dropdowns (50-500 cells). Click "Apply Size" to rebuild grid. Mobile devices auto-detect and use 100√ó150</li>
        </ul>
        <p><strong>Tips:</strong> Avoid a birth minimum of 0 because it causes very unpleasant blinking. Open the birth range to create mind-blowing reactions. <strong>Try wide survival ranges (like 2-6) with narrower evolution ranges (like 4-5) for dynamic color shifting!</strong> Bring the survival minimum down to 0 and watch crystal-like growths form. Use rule sets to organize your discoveries - experiment with different combinations of rules and toggles, then save patterns for each configuration!</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Configuration
        let CELL_SIZE = 4;
        let GRID_WIDTH = 200;
        let GRID_HEIGHT = 150;
        let SPEED = 20;
        
        // Rule parameters (adjustable)
        let BIRTH_MIN_NEIGHBORS = 3;
        let BIRTH_MAX_NEIGHBORS = 3;
        let SURVIVAL_MIN_NEIGHBORS = 2;
        let SURVIVAL_MAX_NEIGHBORS = 3;
        let EVOLUTION_MIN_NEIGHBORS = 4;
        let EVOLUTION_MAX_NEIGHBORS = 4;
        let DEATH_MIN_NEIGHBORS = 5; // Death occurs at this many neighbors or more
        let COLOR_EXPANSION_RATE = 100; // Rate for stagnant cell spawning/neighbor fighting
        
        // Cell states
        const CELL_EMPTY = 0;
        const CELL_WHITE = 1;
        const CELL_WHITE_MOVING = 10; // Special state for moving white cells
        
        // Color hierarchy
        const COLORS = [
            '#000000', // 0: Empty
            '#ffffff', // 1: White
            '#ff0000', // 2: Red
            '#ff8800', // 3: Orange
            '#ffff00', // 4: Yellow
            '#00ff00', // 5: Green
            '#00ffff', // 6: Cyan
            '#0088ff', // 7: Blue
            '#8800ff', // 8: Purple
            '#ff00ff'  // 9: Magenta
        ];
        
        // Grid state
        let grid = [];
        let movingCells = []; // Track moving white cells {x, y, dx, dy}
        let stagnationTimers = []; // Track frames since last change for each cell
        let generation = 0;
        let isPlaying = false;
        let mouseDown = false;
        let lastCell = null;
        let lastUpdate = 0;
        let selectedColor = 1; // Currently selected color for drawing (default: white)
        let eraserMode = false; // Track if eraser is active
        let previousColor = 1; // Track color before eraser was activated
        let zoomLevel = 1; // Zoom level (1 = normal, 2 = 2x zoom, etc)
        let viewOffsetX = 0; // Viewport offset for panning when zoomed
        let viewOffsetY = 0;
        let movingCellsEnabled = true; // Toggle for moving cells feature
        let neighborsFightEnabled = true; // Toggle for neighbors fight feature (ON by default)
        let zoomMode = 0; // 0 = normal, 1 = zoom in mode, 2 = zoom out mode
        let lineToolActive = false; // Toggle for line drawing tool
        let lineStartPoint = null; // First point of line
        let previewLineEnd = null; // Current mouse position for line preview
        let rectangleToolActive = false; // Toggle for rectangle drawing tool
        let rectangleStartPoint = null; // First point of rectangle
        let previewRectangleEnd = null; // Current mouse position for rectangle preview
        let ovalToolActive = false; // Toggle for oval drawing tool
        let ovalStartPoint = null; // First point of oval
        let previewOvalEnd = null; // Current mouse position for oval preview
        let eraserCursorPos = null; // Track mouse position for eraser cursor {x, y} in grid coords
        let eraserSize = 0; // 0 = off, 1 = 5x5 (radius 2.5), 2 = 25x25 (radius 12.5), 3 = 51x51 (radius 25.5)
        let eraserActive = false; // Track if eraser is currently being used (mouse/touch down)
        
        // Selection tool variables
        let selectToolActive = false;
        let pasteMode = false;
        let selectFirstCorner = null;
        let selectSecondCorner = null;
        let previewSelectEnd = null; // Preview position for selection rectangle
        let selectionBox = null;
        let saveButton = null;
        let copiedCells = null;
        let isDraggingSelection = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let selectionOffsetX = 0;
        let selectionOffsetY = 0;
        let originalCellsCleared = false; // Track if original cells have been cleared when dragging
        
        // Pattern save/load storage - now organized by rule sets
        const RULESETS_STORAGE_KEY = 'gameOfLifeRuleSets';
        let isMobile = false;
        
        // Get current rule set signature (used to identify if rules have changed)
        function getCurrentRuleSignature() {
            const nf = neighborsFightEnabled ? 'NF' : 'nf';
            const mc = movingCellsEnabled ? 'MC' : 'mc';
            return `B${BIRTH_MIN_NEIGHBORS}-${BIRTH_MAX_NEIGHBORS}_S${SURVIVAL_MIN_NEIGHBORS}-${SURVIVAL_MAX_NEIGHBORS}_E${EVOLUTION_MIN_NEIGHBORS}-${EVOLUTION_MAX_NEIGHBORS}_D${DEATH_MIN_NEIGHBORS}_C${COLOR_EXPANSION_RATE}_${nf}_${mc}`;
        }
        
        // Get all rule sets from storage
        function getAllRuleSets() {
            try {
                const stored = localStorage.getItem(RULESETS_STORAGE_KEY);
                return stored ? JSON.parse(stored) : {};
            } catch (e) {
                return {};
            }
        }
        
        // Save all rule sets to storage
        function saveAllRuleSets(ruleSets) {
            try {
                localStorage.setItem(RULESETS_STORAGE_KEY, JSON.stringify(ruleSets));
                return true;
            } catch (e) {
                return false;
            }
        }
        
        // Find rule set by signature
        function findRuleSetBySignature(signature) {
            const ruleSets = getAllRuleSets();
            for (let ruleSetName in ruleSets) {
                if (ruleSets[ruleSetName].signature === signature) {
                    return ruleSetName;
                }
            }
            return null;
        }
        
        // Get readable rule set description
        function getRuleDescription(rules) {
            const nf = rules.neighborsFight ? 'ON' : 'OFF';
            const mc = rules.movingCells ? 'ON' : 'OFF';
            return `Birth: ${rules.birthMin}-${rules.birthMax}, Survival: ${rules.survivalMin}-${rules.survivalMax}, Evolution: ${rules.evolutionMin}-${rules.evolutionMax}, Death: ${rules.deathMin}+, Color Exp: ${rules.colorExpansion}, Neighbors Fight: ${nf}, Moving Cells: ${mc}`;
        }
        
        // Erase cells in a circular area based on eraser size
        function eraseCircularArea(x, y) {
            let radius;
            if (eraserSize === 1) {
                radius = 2.5;
            } else if (eraserSize === 2) {
                radius = 12.5;
            } else if (eraserSize === 3) {
                radius = 25.5;
            } else {
                return; // No erasing if eraserSize is 0
            }
            
            const minX = Math.floor(x - radius);
            const maxX = Math.ceil(x + radius);
            const minY = Math.floor(y - radius);
            const maxY = Math.ceil(y + radius);
            
            for (let dy = minY; dy <= maxY; dy++) {
                for (let dx = minX; dx <= maxX; dx++) {
                    const distance = Math.sqrt((dx - x) * (dx - x) + (dy - y) * (dy - y));
                    if (distance <= radius) {
                        const nx = dx;
                        const ny = dy;
                        if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                            grid[ny][nx] = 0;
                        }
                    }
                }
            }
            
            // Also remove any moving cells in the eraser area
            movingCells = movingCells.filter(cell => {
                const dx = cell.x - x;
                const dy = cell.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance > radius;
            });
        }
        
        // Initialize grid
        function initGrid() {
            grid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
            stagnationTimers = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
            movingCells = [];
        }
        
        // Resize canvas
        function resizeCanvas() {
            canvas.width = GRID_WIDTH * CELL_SIZE;
            canvas.height = GRID_HEIGHT * CELL_SIZE;
        }
        
        // Draw grid
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate visible grid area based on zoom
            const cellsVisibleX = Math.ceil(GRID_WIDTH / zoomLevel);
            const cellsVisibleY = Math.ceil(GRID_HEIGHT / zoomLevel);
            
            // Clamp view offset to grid bounds
            viewOffsetX = Math.max(0, Math.min(viewOffsetX, GRID_WIDTH - cellsVisibleX));
            viewOffsetY = Math.max(0, Math.min(viewOffsetY, GRID_HEIGHT - cellsVisibleY));
            
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            
            // Draw regular cells
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    // Only draw cells in visible viewport
                    if (x >= viewOffsetX && x < viewOffsetX + cellsVisibleX &&
                        y >= viewOffsetY && y < viewOffsetY + cellsVisibleY) {
                        
                        const cell = grid[y][x];
                        if (cell > 0 && cell < 10) {
                            ctx.fillStyle = COLORS[cell];
                            const screenX = (x - viewOffsetX) * effectiveCellSize;
                            const screenY = (y - viewOffsetY) * effectiveCellSize;
                            ctx.fillRect(screenX, screenY, effectiveCellSize, effectiveCellSize);
                        }
                    }
                }
            }
            
            // Draw moving cells in their respective colors
            movingCells.forEach(cell => {
                // Only draw moving cells in visible viewport
                if (cell.x >= viewOffsetX && cell.x < viewOffsetX + cellsVisibleX &&
                    cell.y >= viewOffsetY && cell.y < viewOffsetY + cellsVisibleY) {
                    
                    const color = cell.color || 1; // Default to white if no color specified
                    ctx.fillStyle = COLORS[color];
                    const screenX = (cell.x - viewOffsetX) * effectiveCellSize;
                    const screenY = (cell.y - viewOffsetY) * effectiveCellSize;
                    ctx.fillRect(screenX, screenY, effectiveCellSize, effectiveCellSize);
                }
            });
            
            // Draw line tool preview if active and start point is set
            if (lineToolActive && lineStartPoint && previewLineEnd) {
                ctx.strokeStyle = '#ff0000'; // Red line
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                const startScreenX = (lineStartPoint.x - viewOffsetX) * effectiveCellSize + effectiveCellSize / 2;
                const startScreenY = (lineStartPoint.y - viewOffsetY) * effectiveCellSize + effectiveCellSize / 2;
                const endScreenX = (previewLineEnd.x - viewOffsetX) * effectiveCellSize + effectiveCellSize / 2;
                const endScreenY = (previewLineEnd.y - viewOffsetY) * effectiveCellSize + effectiveCellSize / 2;
                
                ctx.moveTo(startScreenX, startScreenY);
                ctx.lineTo(endScreenX, endScreenY);
                ctx.stroke();
            }
            
            // Draw rectangle tool preview
            if (rectangleToolActive && rectangleStartPoint && previewRectangleEnd) {
                ctx.strokeStyle = '#ff0000'; // Red outline
                ctx.lineWidth = 1;
                
                const startScreenX = (rectangleStartPoint.x - viewOffsetX) * effectiveCellSize;
                const startScreenY = (rectangleStartPoint.y - viewOffsetY) * effectiveCellSize;
                const endScreenX = (previewRectangleEnd.x - viewOffsetX) * effectiveCellSize + effectiveCellSize;
                const endScreenY = (previewRectangleEnd.y - viewOffsetY) * effectiveCellSize + effectiveCellSize;
                
                ctx.strokeRect(startScreenX, startScreenY, endScreenX - startScreenX, endScreenY - startScreenY);
            }
            
            // Draw oval tool preview
            if (ovalToolActive && ovalStartPoint && previewOvalEnd) {
                ctx.strokeStyle = '#ff0000'; // Red outline
                ctx.lineWidth = 1;
                
                const centerScreenX = ((ovalStartPoint.x + previewOvalEnd.x) / 2 - viewOffsetX) * effectiveCellSize + effectiveCellSize / 2;
                const centerScreenY = ((ovalStartPoint.y + previewOvalEnd.y) / 2 - viewOffsetY) * effectiveCellSize + effectiveCellSize / 2;
                const radiusX = Math.abs(previewOvalEnd.x - ovalStartPoint.x) * effectiveCellSize / 2 + effectiveCellSize / 2;
                const radiusY = Math.abs(previewOvalEnd.y - ovalStartPoint.y) * effectiveCellSize / 2 + effectiveCellSize / 2;
                
                ctx.beginPath();
                ctx.ellipse(centerScreenX, centerScreenY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Draw selection tool preview (red rectangle outline)
            if (selectToolActive && selectFirstCorner && previewSelectEnd && !selectSecondCorner) {
                ctx.strokeStyle = '#ff0000'; // Red outline
                ctx.lineWidth = 1;
                
                // Use same min/max logic as createSelectionBox
                const minX = Math.min(selectFirstCorner.x, previewSelectEnd.x);
                const minY = Math.min(selectFirstCorner.y, previewSelectEnd.y);
                const maxX = Math.max(selectFirstCorner.x, previewSelectEnd.x);
                const maxY = Math.max(selectFirstCorner.y, previewSelectEnd.y);
                
                const startScreenX = (minX - viewOffsetX) * effectiveCellSize;
                const startScreenY = (minY - viewOffsetY) * effectiveCellSize;
                const endScreenX = (maxX + 1 - viewOffsetX) * effectiveCellSize;
                const endScreenY = (maxY + 1 - viewOffsetY) * effectiveCellSize;
                
                ctx.strokeRect(startScreenX, startScreenY, endScreenX - startScreenX, endScreenY - startScreenY);
            }
            
            // Draw eraser cursor - circle with red outline matching current eraser size
            if (eraserMode && eraserCursorPos && eraserSize > 0) {
                // Center of cursor is at the grid cell position
                const centerScreenX = (eraserCursorPos.x - viewOffsetX) * effectiveCellSize + effectiveCellSize / 2;
                const centerScreenY = (eraserCursorPos.y - viewOffsetY) * effectiveCellSize + effectiveCellSize / 2;
                
                // Radius based on eraser size: 1=2.5 cells, 2=12.5 cells, 3=25.5 cells
                let radius;
                if (eraserSize === 1) {
                    radius = 2.5 * effectiveCellSize;
                } else if (eraserSize === 2) {
                    radius = 12.5 * effectiveCellSize;
                } else if (eraserSize === 3) {
                    radius = 25.5 * effectiveCellSize;
                }
                
                // If actively erasing, draw filled red circle
                if (eraserActive) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; // Semi-transparent red fill
                    ctx.beginPath();
                    ctx.arc(centerScreenX, centerScreenY, radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Always draw the outline
                ctx.strokeStyle = '#ff0000'; // Red outline
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerScreenX, centerScreenY, radius, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            updateStats();
        }
        
        // Count neighbors of specific color (ignoring moving cells)
        function countNeighbors(x, y, targetColor) {
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                        if (grid[ny][nx] === targetColor) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }
        
        // Bresenham's line algorithm
        function drawLine(x0, y0, x1, y1, color) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                // Draw point
                if (x0 >= 0 && x0 < GRID_WIDTH && y0 >= 0 && y0 < GRID_HEIGHT) {
                    grid[y0][x0] = color;
                }
                
                if (x0 === x1 && y0 === y1) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }
        
        // Helper function to draw cells between two points (for smooth continuous drawing)
        // Simply draws the color without toggling
        function drawCellsBetween(x0, y0, x1, y1, color) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                // Simply draw the color at each point
                if (x0 >= 0 && x0 < GRID_WIDTH && y0 >= 0 && y0 < GRID_HEIGHT) {
                    grid[y0][x0] = color;
                }
                
                if (x0 === x1 && y0 === y1) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }
        
        // Helper function to erase cells between two points (for smooth continuous erasing)
        function eraseCellsBetween(x0, y0, x1, y1) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                // Erase at each point along the line
                if (x0 >= 0 && x0 < GRID_WIDTH && y0 >= 0 && y0 < GRID_HEIGHT) {
                    eraseCircularArea(x0, y0);
                }
                
                if (x0 === x1 && y0 === y1) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }
        
        // Draw rectangle outline (not filled)
        function drawRectangle(x0, y0, x1, y1, color) {
            const minX = Math.min(x0, x1);
            const maxX = Math.max(x0, x1);
            const minY = Math.min(y0, y1);
            const maxY = Math.max(y0, y1);
            
            // Draw top and bottom edges
            for (let x = minX; x <= maxX; x++) {
                if (x >= 0 && x < GRID_WIDTH) {
                    if (minY >= 0 && minY < GRID_HEIGHT) {
                        grid[minY][x] = color;
                    }
                    if (maxY >= 0 && maxY < GRID_HEIGHT) {
                        grid[maxY][x] = color;
                    }
                }
            }
            
            // Draw left and right edges
            for (let y = minY; y <= maxY; y++) {
                if (y >= 0 && y < GRID_HEIGHT) {
                    if (minX >= 0 && minX < GRID_WIDTH) {
                        grid[y][minX] = color;
                    }
                    if (maxX >= 0 && maxX < GRID_WIDTH) {
                        grid[y][maxX] = color;
                    }
                }
            }
        }
        
        // Draw oval outline (not filled) using midpoint ellipse algorithm
        function drawOval(x0, y0, x1, y1, color) {
            const centerX = Math.floor((x0 + x1) / 2);
            const centerY = Math.floor((y0 + y1) / 2);
            const radiusX = Math.floor(Math.abs(x1 - x0) / 2);
            const radiusY = Math.floor(Math.abs(y1 - y0) / 2);
            
            if (radiusX === 0 && radiusY === 0) {
                // Just a point
                if (centerX >= 0 && centerX < GRID_WIDTH && centerY >= 0 && centerY < GRID_HEIGHT) {
                    grid[centerY][centerX] = color;
                }
                return;
            }
            
            // Midpoint ellipse algorithm to draw outline
            let x = 0;
            let y = radiusY;
            
            // Region 1
            let d1 = (radiusY * radiusY) - (radiusX * radiusX * radiusY) + (0.25 * radiusX * radiusX);
            let dx = 2 * radiusY * radiusY * x;
            let dy = 2 * radiusX * radiusX * y;
            
            // Plot initial points in all four quadrants
            const plotEllipsePoints = (cx, cy, x, y) => {
                const points = [
                    {x: cx + x, y: cy + y},
                    {x: cx - x, y: cy + y},
                    {x: cx + x, y: cy - y},
                    {x: cx - x, y: cy - y}
                ];
                points.forEach(p => {
                    if (p.x >= 0 && p.x < GRID_WIDTH && p.y >= 0 && p.y < GRID_HEIGHT) {
                        grid[p.y][p.x] = color;
                    }
                });
            };
            
            // Region 1
            while (dx < dy) {
                plotEllipsePoints(centerX, centerY, x, y);
                
                if (d1 < 0) {
                    x++;
                    dx = dx + (2 * radiusY * radiusY);
                    d1 = d1 + dx + (radiusY * radiusY);
                } else {
                    x++;
                    y--;
                    dx = dx + (2 * radiusY * radiusY);
                    dy = dy - (2 * radiusX * radiusX);
                    d1 = d1 + dx - dy + (radiusY * radiusY);
                }
            }
            
            // Region 2
            let d2 = ((radiusY * radiusY) * ((x + 0.5) * (x + 0.5))) + ((radiusX * radiusX) * ((y - 1) * (y - 1))) - (radiusX * radiusX * radiusY * radiusY);
            
            while (y >= 0) {
                plotEllipsePoints(centerX, centerY, x, y);
                
                if (d2 > 0) {
                    y--;
                    dy = dy - (2 * radiusX * radiusX);
                    d2 = d2 + (radiusX * radiusX) - dy;
                } else {
                    y--;
                    x++;
                    dx = dx + (2 * radiusY * radiusY);
                    dy = dy - (2 * radiusX * radiusX);
                    d2 = d2 + dx - dy + (radiusX * radiusX);
                }
            }
        }
        
        // Find all connected cells of the same color (flood fill)
        function findConnectedGroup(startX, startY, targetColor, visited = null) {
            if (visited === null) {
                visited = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(false));
            }
            
            const group = [];
            const queue = [{x: startX, y: startY}];
            visited[startY][startX] = true;
            
            while (queue.length > 0) {
                const {x, y} = queue.shift();
                group.push({x, y});
                
                // Check all 8 neighbors
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                            if (!visited[ny][nx] && grid[ny][nx] === targetColor) {
                                visited[ny][nx] = true;
                                queue.push({x: nx, y: ny});
                            }
                        }
                    }
                }
            }
            
            return group;
        }
        
        // Check if there are any moving white cells in neighboring positions
        function hasMovingWhiteNeighbor(x, y) {
            for (let movingCell of movingCells) {
                const dx = Math.abs(movingCell.x - x);
                const dy = Math.abs(movingCell.y - y);
                if (dx <= 1 && dy <= 1 && !(dx === 0 && dy === 0)) {
                    return true;
                }
            }
            return false;
        }
        
        // Update grid for next generation
        function updateGrid() {
            const newGrid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
            const newStagnationTimers = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
            const newMovingCells = [];
            
            // Process moving white cells first
            movingCells.forEach(movingCell => {
                let {x, y, dx, dy, color, age} = movingCell;
                const movingColor = color || 1; // Default to white if no color specified
                const cellAge = age || 0; // Track how many frames this cell has been moving
                
                // Check if current position has stationary cell of same color - if so, stop moving
                if (grid[y][x] === movingColor) {
                    return; // This moving cell stops and becomes part of the stationary population
                }
                
                // PRIORITY 1: Check if neighboring any colored cells (not same color, not empty) - only if age > 3
                if (cellAge > 3) {
                    let otherColorNeighbor = null;
                    for (let dy2 = -1; dy2 <= 1; dy2++) {
                        for (let dx2 = -1; dx2 <= 1; dx2++) {
                            if (dx2 === 0 && dy2 === 0) continue;
                            const nx = x + dx2;
                            const ny = y + dy2;
                            if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                const neighborCell = grid[ny][nx];
                                // If neighbor is any color except same color or empty
                                if (neighborCell >= 1 && neighborCell <= 9 && neighborCell !== movingColor) {
                                    otherColorNeighbor = {x: nx, y: ny, color: neighborCell};
                                    break;
                                }
                            }
                        }
                        if (otherColorNeighbor) break;
                    }
                    
                    if (otherColorNeighbor) {
                        // Find entire connected group of this color
                        const group = findConnectedGroup(otherColorNeighbor.x, otherColorNeighbor.y, otherColorNeighbor.color);
                        
                        // Convert entire group to moving cell's color
                        group.forEach(cell => {
                            newGrid[cell.y][cell.x] = movingColor;
                            newStagnationTimers[cell.y][cell.x] = 0;
                        });
                        
                        // Stop moving and become stationary at current position
                        newGrid[y][x] = movingColor;
                        newStagnationTimers[y][x] = 0;
                        return;
                    }
                }
                
                // PRIORITY 2: Check if neighboring any stationary cells of SAME color - only if age > 3
                if (cellAge > 3) {
                    let hasSameColorNeighbor = false;
                    for (let dy2 = -1; dy2 <= 1; dy2++) {
                        for (let dx2 = -1; dx2 <= 1; dx2++) {
                            if (dx2 === 0 && dy2 === 0) continue;
                            const nx = x + dx2;
                            const ny = y + dy2;
                            if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                if (grid[ny][nx] === movingColor) {
                                    hasSameColorNeighbor = true;
                                    break;
                                }
                            }
                        }
                        if (hasSameColorNeighbor) break;
                    }
                    
                    if (hasSameColorNeighbor) {
                        // Stop moving and become stationary at current position
                        newGrid[y][x] = movingColor;
                        newStagnationTimers[y][x] = 0;
                        return;
                    }
                }
                
                // Random direction change (30% chance) - rotate by 1/8th (45 degrees)
                if (Math.random() < 0.3) {
                    // Define the 8 directions in clockwise order
                    const directions = [
                        {dx: 0, dy: -1},   // North
                        {dx: 1, dy: -1},   // Northeast
                        {dx: 1, dy: 0},    // East
                        {dx: 1, dy: 1},    // Southeast
                        {dx: 0, dy: 1},    // South
                        {dx: -1, dy: 1},   // Southwest
                        {dx: -1, dy: 0},   // West
                        {dx: -1, dy: -1}   // Northwest
                    ];
                    
                    // Find current direction index
                    let currentIndex = 0;
                    for (let i = 0; i < directions.length; i++) {
                        if (directions[i].dx === dx && directions[i].dy === dy) {
                            currentIndex = i;
                            break;
                        }
                    }
                    
                    // Rotate clockwise or counter-clockwise by 1 position (45 degrees)
                    const rotateClockwise = Math.random() < 0.5;
                    const newIndex = rotateClockwise 
                        ? (currentIndex + 1) % directions.length 
                        : (currentIndex - 1 + directions.length) % directions.length;
                    
                    dx = directions[newIndex].dx;
                    dy = directions[newIndex].dy;
                }
                
                // Calculate new position
                let newX = x + dx;
                let newY = y + dy;
                
                // Bounce off walls
                if (newX < 0 || newX >= GRID_WIDTH) {
                    dx = -dx;
                    newX = x + dx;
                }
                if (newY < 0 || newY >= GRID_HEIGHT) {
                    dy = -dy;
                    newY = y + dy;
                }
                
                // Check if new position has stationary cell of same color - if so, stop
                if (grid[newY][newX] === movingColor) {
                    // Moving cell stops at current position, becomes stationary
                    newGrid[y][x] = movingColor;
                    newStagnationTimers[y][x] = 0;
                    return;
                }
                
                // Check if new position neighbors stationary cells of same color - only if age > 3
                if (cellAge > 3) {
                    let hasSameColorNeighbor = false;
                    for (let dy2 = -1; dy2 <= 1; dy2++) {
                        for (let dx2 = -1; dx2 <= 1; dx2++) {
                            if (dx2 === 0 && dy2 === 0) continue;
                            const nx = newX + dx2;
                            const ny = newY + dy2;
                            if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                if (grid[ny][nx] === movingColor) {
                                    hasSameColorNeighbor = true;
                                    break;
                                }
                            }
                        }
                        if (hasSameColorNeighbor) break;
                    }
                    
                    if (hasSameColorNeighbor) {
                        // Stop moving and become stationary at current position (before moving)
                        newGrid[y][x] = movingColor;
                        newStagnationTimers[y][x] = 0;
                        return;
                    }
                }
                
                // Check if new position neighbors any cells of different color - only if age > 3
                if (cellAge > 3) {
                    let otherColorNeighbor = null;
                    for (let dy2 = -1; dy2 <= 1; dy2++) {
                        for (let dx2 = -1; dx2 <= 1; dx2++) {
                            if (dx2 === 0 && dy2 === 0) continue;
                            const nx = newX + dx2;
                            const ny = newY + dy2;
                            if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                const neighborCell = grid[ny][nx];
                                // If neighbor is any color except same color or empty
                                if (neighborCell >= 1 && neighborCell <= 9 && neighborCell !== movingColor) {
                                    otherColorNeighbor = {x: nx, y: ny, color: neighborCell};
                                    break;
                                }
                            }
                        }
                        if (otherColorNeighbor) break;
                    }
                    
                    if (otherColorNeighbor) {
                        // Find entire connected group of this color
                        const group = findConnectedGroup(otherColorNeighbor.x, otherColorNeighbor.y, otherColorNeighbor.color);
                        
                        // Convert entire group to moving cell's color
                        group.forEach(cell => {
                            newGrid[cell.y][cell.x] = movingColor;
                            newStagnationTimers[cell.y][cell.x] = 0;
                        });
                        
                        // Move to new position and become stationary
                        newGrid[newY][newX] = movingColor;
                        newStagnationTimers[newY][newX] = 0;
                        return;
                    }
                }
                
                // If new position is empty or has another moving cell, continue moving
                if (grid[newY][newX] === CELL_EMPTY || grid[newY][newX] === CELL_WHITE_MOVING) {
                    newMovingCells.push({x: newX, y: newY, dx, dy, color: movingColor, age: cellAge + 1});
                } else {
                    // Hit another obstacle, stop and become stationary at current position
                    newGrid[y][x] = movingColor;
                    newStagnationTimers[y][x] = 0;
                }
            });
            
            // Process regular cells
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    // Skip if this cell was already processed by moving white cells
                    if (newGrid[y][x] !== 0) {
                        continue;
                    }
                    
                    const cell = grid[y][x];
                    
                    if (cell === CELL_EMPTY) {
                        // Check for birth (adjustable neighbor range)
                        for (let color = 1; color <= 9; color++) {
                            const colorNeighbors = countNeighbors(x, y, color);
                            if (colorNeighbors >= BIRTH_MIN_NEIGHBORS && colorNeighbors <= BIRTH_MAX_NEIGHBORS) {
                                newGrid[y][x] = color;
                                newStagnationTimers[y][x] = 0;
                                break;
                            }
                        }
                    } else if (cell >= 1 && cell <= 9) {
                        const neighbors = countNeighbors(x, y, cell);
                        
                        // Magenta special case: evolution range neighbors
                        if (cell === 9 && neighbors >= EVOLUTION_MIN_NEIGHBORS && neighbors <= EVOLUTION_MAX_NEIGHBORS) {
                            if (movingCellsEnabled) {
                                // Moving cells enabled: spawn moving white and die
                                newGrid[y][x] = CELL_EMPTY;
                                newStagnationTimers[y][x] = 0;
                                
                                // Spawn one moving white cell in random empty neighbor
                                const emptyNeighbors = [];
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        if (dx === 0 && dy === 0) continue;
                                        const nx = x + dx;
                                        const ny = y + dy;
                                        if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                            if (grid[ny][nx] === CELL_EMPTY) {
                                                emptyNeighbors.push({x: nx, y: ny, dx, dy});
                                            }
                                        }
                                    }
                                }
                                
                                if (emptyNeighbors.length > 0) {
                                    const spawn = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                                    newMovingCells.push({...spawn, color: 1, age: 0}); // White moving cell with age 0
                                }
                            } else {
                                // Moving cells disabled: evolve to white
                                newGrid[y][x] = 1; // White
                                newStagnationTimers[y][x] = 0;
                            }
                        }
                        // Evolution: evolve to next color based on adjustable neighbor range (CHECK FIRST for priority)
                        else if (neighbors >= EVOLUTION_MIN_NEIGHBORS && neighbors <= EVOLUTION_MAX_NEIGHBORS && cell < 9) {
                            newGrid[y][x] = cell + 1;
                            newStagnationTimers[y][x] = 0;
                        }
                        // Survival: adjustable neighbor range (checked after evolution)
                        else if (neighbors >= SURVIVAL_MIN_NEIGHBORS && neighbors <= SURVIVAL_MAX_NEIGHBORS) {
                            newGrid[y][x] = cell;
                            newStagnationTimers[y][x] = stagnationTimers[y][x] + 1;
                        }
                        // Otherwise: die
                        else {
                            newGrid[y][x] = CELL_EMPTY;
                            newStagnationTimers[y][x] = 0;
                        }
                    }
                }
            }
            
            // Apply stagnation conversion: check cells that haven't changed in 100 frames
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = newGrid[y][x];
                    
                    // Any colored cell (including white) with 3+ neighbors of same color spawns moving cell after Color Expansion Rate
                    // Only if moving cells are enabled
                    if (movingCellsEnabled && cell >= 1 && cell <= 9 && newStagnationTimers[y][x] >= COLOR_EXPANSION_RATE) {
                        const sameColorNeighbors = countNeighbors(x, y, cell);
                        if (sameColorNeighbors >= 3) {
                            // Find an empty neighbor to spawn the moving cell
                            const emptyNeighbors = [];
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                        if (newGrid[ny][nx] === CELL_EMPTY) {
                                            emptyNeighbors.push({x: nx, y: ny, dx, dy});
                                        }
                                    }
                                }
                            }
                            
                            if (emptyNeighbors.length > 0) {
                                const spawn = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                                // Store the color with the moving cell, age starts at 0
                                newMovingCells.push({...spawn, color: cell, age: 0});
                                newStagnationTimers[y][x] = 0; // Reset timer after spawning
                            }
                        }
                    }
                    
                    // Colored cells (not white) that are stagnant do color conversion if Neighbors Fight is enabled
                    if (neighborsFightEnabled && cell >= 2 && cell <= 9 && newStagnationTimers[y][x] >= COLOR_EXPANSION_RATE) {
                        // Check all neighbors
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                    const neighborCell = newGrid[ny][nx];
                                    // If neighbor is a lower color (higher number = higher in hierarchy)
                                    if (neighborCell >= 1 && neighborCell <= 9 && neighborCell < cell) {
                                        // Convert neighbor to match this cell's color
                                        newGrid[ny][nx] = cell;
                                        newStagnationTimers[ny][nx] = 0; // Reset timer for converted cell
                                    }
                                }
                            }
                        }
                        // Reset the stagnation timer after conversion attempt
                        newStagnationTimers[y][x] = 0;
                    }
                }
            }
            
            grid = newGrid;
            stagnationTimers = newStagnationTimers;
            movingCells = newMovingCells;
            generation++;
        }
        
        // Update statistics
        function updateStats() {
            document.getElementById('generation').textContent = generation;
            document.getElementById('zoomDisplay').textContent = zoomLevel.toFixed(2) + 'x';
        }
        
        // Game loop
        function gameLoop(timestamp) {
            // Pause game if select tool becomes active
            if (selectToolActive && isPlaying) {
                isPlaying = false;
                document.getElementById('playPause').textContent = '‚ñ∂ Play';
                return;
            }
            
            if (isPlaying) {
                if (timestamp - lastUpdate > 1000 / SPEED) {
                    updateGrid();
                    drawGrid();
                    lastUpdate = timestamp;
                }
                requestAnimationFrame(gameLoop);
            }
        }
        
        // Clear grid
        function clearGrid() {
            initGrid();
            generation = 0;
            drawGrid();
        }
        
        // Random grid
        function randomGrid() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    grid[y][x] = Math.random() > 0.85 ? selectedColor : 0;
                }
            }
            generation = 0;
            drawGrid();
        }
        
        
        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            // Skip right-click
            if (e.button === 2) {
                e.preventDefault();
                return;
            }
            
            if (e.button !== 0) return; // Only process left clicks
            
            const rect = canvas.getBoundingClientRect();
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            const x = Math.floor(viewOffsetX + (e.clientX - rect.left) / effectiveCellSize) - 1;
            const y = Math.floor(viewOffsetY + (e.clientY - rect.top) / effectiveCellSize) - 1;
            
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                // Paste mode handling
                if (pasteMode) {
                    pasteSelection(x, y);
                    return;
                }
                
                // Selection tool handling
                if (selectToolActive) {
                    if (isInsideSelection(x, y) && selectFirstCorner && selectSecondCorner) {
                        // Start dragging - clear original cells immediately
                        isDraggingSelection = true;
                        dragStartX = x;
                        dragStartY = y;
                        
                        if (!copiedCells) {
                            copySelection();
                        }
                        
                        // Clear original cell positions when starting to drag
                        if (!originalCellsCleared) {
                            const minX = Math.min(selectFirstCorner.x, selectSecondCorner.x);
                            const minY = Math.min(selectFirstCorner.y, selectSecondCorner.y);
                            
                            for (let i = 0; i < copiedCells.cells.length; i++) {
                                const cell = copiedCells.cells[i];
                                const originalX = minX + cell.x;
                                const originalY = minY + cell.y;
                                if (originalX >= 0 && originalX < GRID_WIDTH && originalY >= 0 && originalY < GRID_HEIGHT) {
                                    grid[originalY][originalX] = CELL_EMPTY;
                                }
                            }
                            originalCellsCleared = true;
                            drawGrid();
                        }
                    } else {
                        // Start new selection or set second corner
                        if (!selectFirstCorner) {
                            selectFirstCorner = {x, y};
                            selectSecondCorner = null;
                            removeSelectionBox();
                            originalCellsCleared = false;
                        } else if (!selectSecondCorner) {
                            selectSecondCorner = {x, y};
                            previewSelectEnd = null; // Clear preview
                            drawGrid(); // Redraw to remove preview
                            createSelectionBox(selectFirstCorner.x, selectFirstCorner.y, selectSecondCorner.x, selectSecondCorner.y);
                            copySelection();
                            originalCellsCleared = false;
                        }
                    }
                    return;
                }
                
                if (zoomMode === 1) {
                    // Zoom in mode
                    zoomLevel = Math.min(10, zoomLevel + 1);
                    
                    // Center view on clicked cell
                    const cellsVisibleX = Math.ceil(GRID_WIDTH / zoomLevel);
                    const cellsVisibleY = Math.ceil(GRID_HEIGHT / zoomLevel);
                    
                    viewOffsetX = Math.floor(x - cellsVisibleX / 2);
                    viewOffsetY = Math.floor(y - cellsVisibleY / 2);
                    
                    drawGrid();
                } else if (zoomMode === 2) {
                    // Zoom out mode - minimum zoom is 1.0 to prevent showing black space
                    if (zoomLevel > 1.0) {
                        const gridX = x;
                        const gridY = y;
                        
                        zoomLevel = Math.max(1.0, zoomLevel - 1);
                        
                        // Recenter view on the clicked position
                        const cellsVisibleX = Math.ceil(GRID_WIDTH / zoomLevel);
                        const cellsVisibleY = Math.ceil(GRID_HEIGHT / zoomLevel);
                        
                        viewOffsetX = Math.floor(gridX - cellsVisibleX / 2);
                        viewOffsetY = Math.floor(gridY - cellsVisibleY / 2);
                        
                        drawGrid();
                    }
                } else {
                    // Normal drawing mode or shape tool modes
                    if (lineToolActive) {
                        // Line tool mode
                        if (!lineStartPoint) {
                            lineStartPoint = {x, y};
                            previewLineEnd = {x, y};
                        } else {
                            drawLine(lineStartPoint.x, lineStartPoint.y, x, y, selectedColor);
                            lineStartPoint = null;
                            previewLineEnd = null;
                            drawGrid();
                        }
                    } else if (rectangleToolActive) {
                        // Rectangle tool mode
                        if (!rectangleStartPoint) {
                            rectangleStartPoint = {x, y};
                            previewRectangleEnd = {x, y};
                        } else {
                            drawRectangle(rectangleStartPoint.x, rectangleStartPoint.y, x, y, selectedColor);
                            rectangleStartPoint = null;
                            previewRectangleEnd = null;
                            drawGrid();
                        }
                    } else if (ovalToolActive) {
                        // Oval tool mode
                        if (!ovalStartPoint) {
                            ovalStartPoint = {x, y};
                            previewOvalEnd = {x, y};
                        } else {
                            drawOval(ovalStartPoint.x, ovalStartPoint.y, x, y, selectedColor);
                            ovalStartPoint = null;
                            previewOvalEnd = null;
                            drawGrid();
                        }
                    } else {
                        // Normal drawing mode - adjust coordinates back for direct drawing
                        mouseDown = true;
                        const drawX = x + 1;  // Compensate for offset for direct drawing
                        const drawY = y + 1;
                        if (eraserMode) {
                            eraserActive = true;
                            eraseCircularArea(drawX, drawY);
                        } else {
                            // Draw with selected color directly (no toggle)
                            grid[drawY][drawX] = selectedColor;
                        }
                        lastCell = {x: drawX, y: drawY};
                        drawGrid();
                    }
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            // Handle selection dragging
            if (isDraggingSelection) {
                const rect = canvas.getBoundingClientRect();
                const effectiveCellSize = CELL_SIZE * zoomLevel;
                const x = Math.floor(viewOffsetX + (e.clientX - rect.left) / effectiveCellSize) - 1;
                const y = Math.floor(viewOffsetY + (e.clientY - rect.top) / effectiveCellSize) - 1;
                
                selectionOffsetX = x - dragStartX;
                selectionOffsetY = y - dragStartY;
                
                if (selectFirstCorner && selectSecondCorner) {
                    const minX = Math.min(selectFirstCorner.x, selectSecondCorner.x) + selectionOffsetX;
                    const minY = Math.min(selectFirstCorner.y, selectSecondCorner.y) + selectionOffsetY;
                    const maxX = Math.max(selectFirstCorner.x, selectSecondCorner.x) + selectionOffsetX;
                    const maxY = Math.max(selectFirstCorner.y, selectSecondCorner.y) + selectionOffsetY;
                    
                    createSelectionBox(minX, minY, maxX, maxY);
                    
                    // Show live preview of cells at new position
                    drawGrid(); // First draw the grid without the moved cells
                    
                    // Draw the cells at their new position
                    const baseX = Math.min(selectFirstCorner.x, selectSecondCorner.x);
                    const baseY = Math.min(selectFirstCorner.y, selectSecondCorner.y);
                    const newX = baseX + selectionOffsetX;
                    const newY = baseY + selectionOffsetY;
                    
                    for (let i = 0; i < copiedCells.cells.length; i++) {
                        const cell = copiedCells.cells[i];
                        const gridX = newX + cell.x;
                        const gridY = newY + cell.y;
                        if (gridX >= 0 && gridX < GRID_WIDTH && gridY >= 0 && gridY < GRID_HEIGHT) {
                            const drawX = (gridX - viewOffsetX) * CELL_SIZE;
                            const drawY = (gridY - viewOffsetY) * CELL_SIZE;
                            ctx.fillStyle = COLORS[cell.value];
                            ctx.fillRect(drawX, drawY, CELL_SIZE, CELL_SIZE);
                        }
                    }
                }
                return;
            }
            
            if (!mouseDown || zoomMode !== 0 || lineToolActive || rectangleToolActive || ovalToolActive || selectToolActive) return;
            const rect = canvas.getBoundingClientRect();
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            const x = Math.floor(viewOffsetX + (e.clientX - rect.left) / effectiveCellSize) - 1;
            const y = Math.floor(viewOffsetY + (e.clientY - rect.top) / effectiveCellSize) - 1;
            
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                // Adjust coordinates for direct drawing
                const drawX = x + 1;
                const drawY = y + 1;
                
                if (!lastCell || lastCell.x !== drawX || lastCell.y !== drawY) {
                    if (eraserMode) {
                        eraserActive = true;
                        // Interpolate eraser between last position and current position
                        if (lastCell) {
                            eraseCellsBetween(lastCell.x, lastCell.y, drawX, drawY);
                        } else {
                            eraseCircularArea(drawX, drawY);
                        }
                    } else {
                        // Interpolate drawing between last position and current position
                        if (lastCell) {
                            drawCellsBetween(lastCell.x, lastCell.y, drawX, drawY, selectedColor);
                        } else {
                            // First cell
                            grid[drawY][drawX] = selectedColor;
                        }
                    }
                    lastCell = {x: drawX, y: drawY};
                    drawGrid();
                }
            }
        });
        
        // Separate mousemove handlers for shape tool previews
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            const x = Math.floor(viewOffsetX + (e.clientX - rect.left) / effectiveCellSize) - 1;
            const y = Math.floor(viewOffsetY + (e.clientY - rect.top) / effectiveCellSize) - 1;
            
            // Track eraser cursor position - adjust for drawing offset
            if (eraserMode && x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                eraserCursorPos = {x: x + 1, y: y + 1};
                canvas.classList.add('eraser-cursor');
                drawGrid();
            } else if (eraserMode) {
                eraserCursorPos = null;
                canvas.classList.add('eraser-cursor');
            } else {
                eraserCursorPos = null;
                canvas.classList.remove('eraser-cursor');
            }
            
            if (lineToolActive && lineStartPoint) {
                if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                    previewLineEnd = {x, y};
                    drawGrid();
                }
            } else if (rectangleToolActive && rectangleStartPoint) {
                if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                    previewRectangleEnd = {x, y};
                    drawGrid();
                }
            } else if (ovalToolActive && ovalStartPoint) {
                if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                    previewOvalEnd = {x, y};
                    drawGrid();
                }
            } else if (selectToolActive && selectFirstCorner && !selectSecondCorner) {
                if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                    previewSelectEnd = {x, y};
                    drawGrid();
                }
            }
        });
        
        // Clear eraser cursor when mouse leaves canvas
        canvas.addEventListener('mouseleave', () => {
            eraserCursorPos = null;
            canvas.classList.remove('eraser-cursor');
            mouseDown = false;
            lastCell = null;
            if (eraserActive) {
                eraserActive = false;
            }
            if (eraserMode) {
                drawGrid(); // Redraw to remove cursor
            }
        });
        
        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Touch events for mobile support
        let lastTouchCell = null;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling while drawing
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            const x = Math.floor(viewOffsetX + (touch.clientX - rect.left) / effectiveCellSize) - 1;
            const y = Math.floor(viewOffsetY + (touch.clientY - rect.top) / effectiveCellSize) - 1;
            
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                // Paste mode handling
                if (pasteMode) {
                    pasteSelection(x, y);
                    return;
                }
                
                // Selection tool handling
                if (selectToolActive) {
                    if (isInsideSelection(x, y) && selectFirstCorner && selectSecondCorner) {
                        // Start dragging - clear original cells immediately
                        isDraggingSelection = true;
                        dragStartX = x;
                        dragStartY = y;
                        
                        if (!copiedCells) {
                            copySelection();
                        }
                        
                        // Clear original cell positions when starting to drag
                        if (!originalCellsCleared) {
                            const minX = Math.min(selectFirstCorner.x, selectSecondCorner.x);
                            const minY = Math.min(selectFirstCorner.y, selectSecondCorner.y);
                            
                            for (let i = 0; i < copiedCells.cells.length; i++) {
                                const cell = copiedCells.cells[i];
                                const originalX = minX + cell.x;
                                const originalY = minY + cell.y;
                                if (originalX >= 0 && originalX < GRID_WIDTH && originalY >= 0 && originalY < GRID_HEIGHT) {
                                    grid[originalY][originalX] = CELL_EMPTY;
                                }
                            }
                            originalCellsCleared = true;
                            drawGrid();
                        }
                    } else {
                        // Start new selection or set second corner
                        if (!selectFirstCorner) {
                            selectFirstCorner = {x, y};
                            selectSecondCorner = null;
                            removeSelectionBox();
                            originalCellsCleared = false;
                        } else if (!selectSecondCorner) {
                            selectSecondCorner = {x, y};
                            previewSelectEnd = null; // Clear preview
                            drawGrid(); // Redraw to remove preview
                            createSelectionBox(selectFirstCorner.x, selectFirstCorner.y, selectSecondCorner.x, selectSecondCorner.y);
                            copySelection();
                            originalCellsCleared = false;
                        }
                    }
                    return;
                }
                
                if (zoomMode === 1) {
                    // Zoom in mode
                    zoomLevel = Math.min(10, zoomLevel + 1);
                    
                    // Center view on clicked cell
                    const cellsVisibleX = Math.ceil(GRID_WIDTH / zoomLevel);
                    const cellsVisibleY = Math.ceil(GRID_HEIGHT / zoomLevel);
                    
                    viewOffsetX = Math.floor(x - cellsVisibleX / 2);
                    viewOffsetY = Math.floor(y - cellsVisibleY / 2);
                    
                    drawGrid();
                } else if (zoomMode === 2) {
                    // Zoom out mode - minimum zoom is 1.0 to prevent showing black space
                    if (zoomLevel > 1.0) {
                        const gridX = x;
                        const gridY = y;
                        
                        zoomLevel = Math.max(1.0, zoomLevel - 1);
                        
                        // Recenter view on the clicked position
                        const cellsVisibleX = Math.ceil(GRID_WIDTH / zoomLevel);
                        const cellsVisibleY = Math.ceil(GRID_HEIGHT / zoomLevel);
                        
                        viewOffsetX = Math.floor(gridX - cellsVisibleX / 2);
                        viewOffsetY = Math.floor(gridY - cellsVisibleY / 2);
                        
                        drawGrid();
                    }
                } else {
                    // Normal drawing mode or shape tool modes
                    if (lineToolActive) {
                        // Line tool mode
                        if (!lineStartPoint) {
                            lineStartPoint = {x, y};
                        } else {
                            drawLine(lineStartPoint.x, lineStartPoint.y, x, y, selectedColor);
                            lineStartPoint = null;
                            drawGrid();
                        }
                    } else if (rectangleToolActive) {
                        // Rectangle tool mode
                        if (!rectangleStartPoint) {
                            rectangleStartPoint = {x, y};
                        } else {
                            drawRectangle(rectangleStartPoint.x, rectangleStartPoint.y, x, y, selectedColor);
                            rectangleStartPoint = null;
                            drawGrid();
                        }
                    } else if (ovalToolActive) {
                        // Oval tool mode
                        if (!ovalStartPoint) {
                            ovalStartPoint = {x, y};
                        } else {
                            drawOval(ovalStartPoint.x, ovalStartPoint.y, x, y, selectedColor);
                            ovalStartPoint = null;
                            drawGrid();
                        }
                    } else {
                        // Normal drawing mode - adjust coordinates back for direct drawing
                        const drawX = x + 1;
                        const drawY = y + 1;
                        if (eraserMode) {
                            eraserActive = true;
                            eraserCursorPos = {x: drawX, y: drawY}; // Set cursor position for visual feedback
                            eraseCircularArea(drawX, drawY);
                        } else {
                            // Draw with selected color directly (no toggle)
                            grid[drawY][drawX] = selectedColor;
                        }
                        lastTouchCell = {x: drawX, y: drawY};
                        drawGrid();
                    }
                }
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling while drawing
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            const x = Math.floor(viewOffsetX + (touch.clientX - rect.left) / effectiveCellSize) - 1;
            const y = Math.floor(viewOffsetY + (touch.clientY - rect.top) / effectiveCellSize) - 1;
            
            // Handle selection dragging
            if (isDraggingSelection) {
                selectionOffsetX = x - dragStartX;
                selectionOffsetY = y - dragStartY;
                
                if (selectFirstCorner && selectSecondCorner) {
                    const minX = Math.min(selectFirstCorner.x, selectSecondCorner.x) + selectionOffsetX;
                    const minY = Math.min(selectFirstCorner.y, selectSecondCorner.y) + selectionOffsetY;
                    const maxX = Math.max(selectFirstCorner.x, selectSecondCorner.x) + selectionOffsetX;
                    const maxY = Math.max(selectFirstCorner.y, selectSecondCorner.y) + selectionOffsetY;
                    
                    createSelectionBox(minX, minY, maxX, maxY);
                    
                    // Show live preview of cells at new position
                    drawGrid();
                    
                    const baseX = Math.min(selectFirstCorner.x, selectSecondCorner.x);
                    const baseY = Math.min(selectFirstCorner.y, selectSecondCorner.y);
                    const newX = baseX + selectionOffsetX;
                    const newY = baseY + selectionOffsetY;
                    
                    for (let i = 0; i < copiedCells.cells.length; i++) {
                        const cell = copiedCells.cells[i];
                        const gridX = newX + cell.x;
                        const gridY = newY + cell.y;
                        if (gridX >= 0 && gridX < GRID_WIDTH && gridY >= 0 && gridY < GRID_HEIGHT) {
                            const drawX = (gridX - viewOffsetX) * CELL_SIZE;
                            const drawY = (gridY - viewOffsetY) * CELL_SIZE;
                            ctx.fillStyle = COLORS[cell.value];
                            ctx.fillRect(drawX, drawY, CELL_SIZE, CELL_SIZE);
                        }
                    }
                }
                return;
            }
            
            if (zoomMode !== 0 || lineToolActive || rectangleToolActive || ovalToolActive || selectToolActive) return;
            
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                // Adjust coordinates for direct drawing
                const drawX = x + 1;
                const drawY = y + 1;
                
                if (!lastTouchCell || lastTouchCell.x !== drawX || lastTouchCell.y !== drawY) {
                    if (eraserMode) {
                        eraserActive = true;
                        eraserCursorPos = {x: drawX, y: drawY}; // Set cursor position for visual feedback
                        // Interpolate eraser between last position and current position
                        if (lastTouchCell) {
                            eraseCellsBetween(lastTouchCell.x, lastTouchCell.y, drawX, drawY);
                        } else {
                            eraseCircularArea(drawX, drawY);
                        }
                    } else {
                        // Interpolate drawing between last position and current position
                        if (lastTouchCell) {
                            drawCellsBetween(lastTouchCell.x, lastTouchCell.y, drawX, drawY, selectedColor);
                        } else {
                            // First cell
                            grid[drawY][drawX] = selectedColor;
                        }
                    }
                    lastTouchCell = {x: drawX, y: drawY};
                    drawGrid();
                }
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            if (isDraggingSelection) {
                isDraggingSelection = false;
                // Apply the selection to update positions
                if (selectToolActive && selectFirstCorner && selectSecondCorner && copiedCells) {
                    applySelection();
                }
            }
            
            lastTouchCell = null;
            if (eraserActive) {
                eraserActive = false;
                eraserCursorPos = null; // Clear cursor position
                drawGrid(); // Redraw to remove the filled circle
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            if (isDraggingSelection) {
                isDraggingSelection = false;
                // Apply the selection to update positions
                if (selectToolActive && selectFirstCorner && selectSecondCorner && copiedCells) {
                    applySelection();
                }
            }
            mouseDown = false;
            lastCell = null;
            if (eraserActive) {
                eraserActive = false;
                drawGrid(); // Redraw to remove the filled circle
            }
        });
        
        // Control events
        document.getElementById('playPause').addEventListener('click', function() {
            deactivateZoom();
            
            // If trying to play, deactivate select tool first
            if (!isPlaying && selectToolActive) {
                deactivateSelectTool();
            }
            
            // Don't allow playing while select tool is active
            if (selectToolActive) {
                return;
            }
            
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
            if (isPlaying) {
                requestAnimationFrame(gameLoop);
            }
        });
        
        document.getElementById('step').addEventListener('click', () => {
            deactivateZoom();
            updateGrid();
            drawGrid();
        });
        
        document.getElementById('clear').addEventListener('click', () => {
            deactivateZoom();
            deactivateSelectTool();
            clearGrid();
        });
        
        document.getElementById('randomButton').addEventListener('click', () => {
            deactivateZoom();
            randomGrid();
        });
        
        // Select button
        document.getElementById('selectButton').addEventListener('click', function() {
            if (selectToolActive) {
                // Deactivate select tool - leave cells where they are
                deactivateSelectTool();
            } else {
                // Activate select tool
                selectToolActive = true;
                
                // Pause game
                if (isPlaying) {
                    isPlaying = false;
                    document.getElementById('playPause').textContent = '‚ñ∂ Play';
                }
                
                // Deactivate other tools
                deactivateZoom();
                deactivateLineTool();
                deactivateRectangleTool();
                deactivateOvalTool();
                deactivateEraser();
                deactivatePasteMode();
                
                this.classList.add('active');
                
                selectFirstCorner = null;
                selectSecondCorner = null;
                previewSelectEnd = null; // Clear preview
                            drawGrid(); // Redraw to remove preview
                removeSelectionBox();
                originalCellsCleared = false;
            }
        });
        
        // Paste button
        document.getElementById('pasteButton').addEventListener('click', function() {
            if (!copiedCells || !copiedCells.cells || copiedCells.cells.length === 0) {
                return; // No cells to paste
            }
            
            pasteMode = !pasteMode;
            this.classList.toggle('active');
            
            if (pasteMode) {
                // Deactivate other tools when paste mode is activated
                deactivateZoom();
                deactivateLineTool();
                deactivateRectangleTool();
                deactivateOvalTool();
                deactivateEraser();
                deactivateSelectTool();
            }
        });
        
        // Save and Load buttons
        document.getElementById('saveButton').addEventListener('click', () => {
            saveGame();
        });
        
        // Function to reattach modal event listeners after innerHTML replacement
        function reattachModalEventListeners() {
            // Close modal button
            const closeBtn = document.getElementById('closeModal');
            if (closeBtn) {
                closeBtn.onclick = () => {
                    document.getElementById('loadModal').style.display = 'none';
                };
            }
            
            // Export All button
            const exportBtn = document.getElementById('exportAllButton');
            if (exportBtn) {
                exportBtn.onclick = () => {
                    exportAllRuleSets();
                };
            }
            
            // Import button
            const importBtn = document.getElementById('importButton');
            if (importBtn) {
                importBtn.onclick = () => {
                    document.getElementById('importFileInput').click();
                };
            }
        }
        
        document.getElementById('loadButton').addEventListener('click', () => {
            loadGame();
        });
        
        // Load Pattern button
        document.getElementById('loadPatternButton').addEventListener('click', function() {
            if (isMobile) return; // Don't show on mobile
            loadPatternModal();
        });
        
        // Close modal button
        document.getElementById('closeModal').addEventListener('click', () => {
            document.getElementById('loadModal').style.display = 'none';
        });
        
        // Export All button
        document.getElementById('exportAllButton').addEventListener('click', () => {
            exportAllRuleSets();
        });
        
        // Import button
        document.getElementById('importButton').addEventListener('click', () => {
            document.getElementById('importFileInput').click();
        });
        
        // Import file handler
        document.getElementById('importFileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                importRuleSets(file);
            }
            e.target.value = ''; // Reset input
        });
        
        // Close modal when clicking outside
        document.getElementById('loadModal').addEventListener('click', (e) => {
            if (e.target.id === 'loadModal') {
                document.getElementById('loadModal').style.display = 'none';
            }
        });
        
        document.getElementById('toggleNeighborsFight').addEventListener('click', function() {
            deactivateZoom();
            neighborsFightEnabled = !neighborsFightEnabled;
            this.textContent = neighborsFightEnabled ? 'Neighbors Fight: ON' : 'Neighbors Fight: OFF';
            this.classList.toggle('active');
        });
        
        document.getElementById('toggleMovingCells').addEventListener('click', function() {
            deactivateZoom();
            movingCellsEnabled = !movingCellsEnabled;
            this.textContent = movingCellsEnabled ? 'Moving Cells: ON' : 'Moving Cells: OFF';
            this.classList.toggle('active');
            
            // Clear all existing moving cells when disabled
            if (!movingCellsEnabled) {
                movingCells = [];
                drawGrid();
            }
        });
        
        document.getElementById('colorExpansionRate').addEventListener('input', (e) => {
            deactivateZoom();
            COLOR_EXPANSION_RATE = parseInt(e.target.value);
            document.getElementById('colorExpansionValue').textContent = COLOR_EXPANSION_RATE;
        });
        
        document.getElementById('lineToolButton').addEventListener('click', function() {
            deactivateZoom();
            deactivateRectangleTool();
            deactivateOvalTool();
            deactivateEraser();
            deactivateSelectTool();
            deactivatePasteMode();
            lineToolActive = !lineToolActive;
            this.classList.toggle('active');
            
            if (!lineToolActive) {
                lineStartPoint = null;
                previewLineEnd = null;
                drawGrid();
            }
        });
        
        document.getElementById('rectangleToolButton').addEventListener('click', function() {
            deactivateZoom();
            deactivateLineTool();
            deactivateOvalTool();
            deactivateEraser();
            deactivateSelectTool();
            deactivatePasteMode();
            rectangleToolActive = !rectangleToolActive;
            this.classList.toggle('active');
            
            if (!rectangleToolActive) {
                rectangleStartPoint = null;
                previewRectangleEnd = null;
                drawGrid();
            }
        });
        
        document.getElementById('ovalToolButton').addEventListener('click', function() {
            deactivateZoom();
            deactivateLineTool();
            deactivateRectangleTool();
            deactivateEraser();
            deactivateSelectTool();
            deactivatePasteMode();
            ovalToolActive = !ovalToolActive;
            this.classList.toggle('active');
            
            if (!ovalToolActive) {
                ovalStartPoint = null;
                previewOvalEnd = null;
                drawGrid();
            }
        });
        
        document.getElementById('zoomButton').addEventListener('click', function() {
            deactivateEraser();
            deactivateSelectTool();
            deactivatePasteMode();
            zoomMode = (zoomMode + 1) % 3; // Cycle through 0, 1, 2
            
            if (zoomMode === 0) {
                this.textContent = 'Zoom: OFF';
                this.classList.remove('active');
            } else if (zoomMode === 1) {
                this.textContent = 'Zoom: IN';
                this.classList.add('active');
            } else if (zoomMode === 2) {
                this.textContent = 'Zoom: OUT';
                this.classList.add('active');
            }
        });
        
        // Function to deactivate zoom mode
        function deactivateZoom() {
            if (zoomMode !== 0) {
                zoomMode = 0;
                previewSelectEnd = null; // Clear selection preview
                const zoomButton = document.getElementById('zoomButton');
                zoomButton.textContent = 'Zoom: OFF';
                zoomButton.classList.remove('active');
                drawGrid(); // Redraw to clear preview
            }
        }
        
        // Calculate minimum zoom level to fit entire canvas
        function getMinZoomLevel() {
            // Minimum zoom is 1.0 - this ensures we never zoom out to show black space
            // beyond the canvas dimensions. At zoom level 1.0, the entire canvas is visible.
            return 1.0;
        }
        
        // Function to deactivate line tool
        function deactivateLineTool() {
            if (lineToolActive) {
                lineToolActive = false;
                lineStartPoint = null;
                previewLineEnd = null;
                previewSelectEnd = null; // Clear selection preview
                const lineButton = document.getElementById('lineToolButton');
                lineButton.classList.remove('active');
                drawGrid(); // Redraw to clear preview line
            }
        }
        
        // Function to deactivate rectangle tool
        function deactivateRectangleTool() {
            if (rectangleToolActive) {
                rectangleToolActive = false;
                rectangleStartPoint = null;
                previewRectangleEnd = null;
                previewSelectEnd = null; // Clear selection preview
                const rectButton = document.getElementById('rectangleToolButton');
                rectButton.classList.remove('active');
                drawGrid();
            }
        }
        
        // Function to deactivate oval tool
        function deactivateOvalTool() {
            if (ovalToolActive) {
                ovalToolActive = false;
                ovalStartPoint = null;
                previewOvalEnd = null;
                previewSelectEnd = null; // Clear selection preview
                const ovalButton = document.getElementById('ovalToolButton');
                ovalButton.classList.remove('active');
                drawGrid();
            }
        }
        
        // Function to deactivate eraser
        function deactivateEraser() {
            if (eraserMode) {
                eraserMode = false;
                eraserSize = 0;
                eraserCursorPos = null;
                previewSelectEnd = null; // Clear selection preview
                canvas.classList.remove('eraser-cursor');
                const eraserButton = document.getElementById('eraserButton');
                eraserButton.classList.remove('active');
                drawGrid();
            }
        }
        
        // Selection tool functions
        function createSelectionBox(x1, y1, x2, y2) {
            removeSelectionBox();
            
            const rect = canvas.getBoundingClientRect();
            const minX = Math.min(x1, x2);
            const minY = Math.min(y1, y2);
            const maxX = Math.max(x1, x2);
            const maxY = Math.max(y1, y2);
            
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            const pixelX1 = (minX - viewOffsetX) * effectiveCellSize;
            const pixelY1 = (minY - viewOffsetY) * effectiveCellSize;
            const pixelX2 = (maxX + 1 - viewOffsetX) * effectiveCellSize;
            const pixelY2 = (maxY + 1 - viewOffsetY) * effectiveCellSize;
            
            selectionBox = document.createElement('div');
            selectionBox.className = 'selection-box';
            // Use fixed positioning with scroll offset for accurate placement
            selectionBox.style.left = (rect.left + window.scrollX + pixelX1) + 'px';
            selectionBox.style.top = (rect.top + window.scrollY + pixelY1) + 'px';
            selectionBox.style.width = (pixelX2 - pixelX1) + 'px';
            selectionBox.style.height = (pixelY2 - pixelY1) + 'px';
            document.body.appendChild(selectionBox);
            
            // Create save button (bottom-right corner) - only if not mobile
            if (!isMobile) {
                saveButton = document.createElement('button');
                saveButton.className = 'save-button';
                saveButton.textContent = 'üíæ';
                saveButton.title = 'Save Pattern';
                saveButton.style.right = '-24px';
                saveButton.style.bottom = '-24px';
                saveButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    savePattern();
                });
                selectionBox.appendChild(saveButton);
            }
        }
        
        function removeSelectionBox() {
            if (selectionBox) {
                selectionBox.remove();
                selectionBox = null;
            }
            if (saveButton) {
                saveButton.remove();
                saveButton = null;
            }
        }
        
        function copySelection() {
            if (!selectFirstCorner || !selectSecondCorner) return;
            
            const minX = Math.min(selectFirstCorner.x, selectSecondCorner.x);
            const minY = Math.min(selectFirstCorner.y, selectSecondCorner.y);
            const maxX = Math.max(selectFirstCorner.x, selectSecondCorner.x);
            const maxY = Math.max(selectFirstCorner.y, selectSecondCorner.y);
            
            // Store only living cells with their relative positions
            copiedCells = {
                minX: minX,
                minY: minY,
                cells: [] // Array of {x, y, value} for living cells only
            };
            
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    if (grid[y][x] !== CELL_EMPTY) {
                        copiedCells.cells.push({
                            x: x - minX,  // Store relative position
                            y: y - minY,
                            value: grid[y][x]
                        });
                    }
                }
            }
        }
        
        function pasteSelection(targetX, targetY) {
            if (!copiedCells || !copiedCells.cells) return;
            
            // Calculate the center of the copied cells pattern
            let minRelX = Infinity, maxRelX = -Infinity;
            let minRelY = Infinity, maxRelY = -Infinity;
            
            for (let i = 0; i < copiedCells.cells.length; i++) {
                const cell = copiedCells.cells[i];
                minRelX = Math.min(minRelX, cell.x);
                maxRelX = Math.max(maxRelX, cell.x);
                minRelY = Math.min(minRelY, cell.y);
                maxRelY = Math.max(maxRelY, cell.y);
            }
            
            // Calculate center offset from minRelX/minRelY
            const centerOffsetX = minRelX + Math.floor((maxRelX - minRelX) / 2);
            const centerOffsetY = minRelY + Math.floor((maxRelY - minRelY) / 2);
            
            // Paste centered on the target position
            for (let i = 0; i < copiedCells.cells.length; i++) {
                const cell = copiedCells.cells[i];
                const gridX = targetX + cell.x - centerOffsetX;
                const gridY = targetY + cell.y - centerOffsetY;
                if (gridX >= 0 && gridX < GRID_WIDTH && gridY >= 0 && gridY < GRID_HEIGHT) {
                    grid[gridY][gridX] = cell.value;
                }
            }
            drawGrid();
        }
        
        function applySelection() {
            if (!selectFirstCorner || !selectSecondCorner || !copiedCells || !copiedCells.cells) return;
            
            const minX = Math.min(selectFirstCorner.x, selectSecondCorner.x);
            const minY = Math.min(selectFirstCorner.y, selectSecondCorner.y);
            const maxX = Math.max(selectFirstCorner.x, selectSecondCorner.x);
            const maxY = Math.max(selectFirstCorner.y, selectSecondCorner.y);
            
            // Place cells at new location (original cells already cleared during drag)
            const newX = minX + selectionOffsetX;
            const newY = minY + selectionOffsetY;
            
            for (let i = 0; i < copiedCells.cells.length; i++) {
                const cell = copiedCells.cells[i];
                const gridX = newX + cell.x;
                const gridY = newY + cell.y;
                if (gridX >= 0 && gridX < GRID_WIDTH && gridY >= 0 && gridY < GRID_HEIGHT) {
                    grid[gridY][gridX] = cell.value;
                }
            }
            
            // Update selection corners to new position so we can drag from there again
            selectFirstCorner.x = minX + selectionOffsetX;
            selectFirstCorner.y = minY + selectionOffsetY;
            selectSecondCorner.x = maxX + selectionOffsetX;
            selectSecondCorner.y = maxY + selectionOffsetY;
            
            // Update the selection box to new position
            createSelectionBox(selectFirstCorner.x, selectFirstCorner.y, selectSecondCorner.x, selectSecondCorner.y);
            
            selectionOffsetX = 0;
            selectionOffsetY = 0;
            originalCellsCleared = false; // Reset for next drag
            drawGrid();
        }
        
        function isInsideSelection(x, y) {
            if (!selectFirstCorner || !selectSecondCorner) return false;
            
            const minX = Math.min(selectFirstCorner.x, selectSecondCorner.x);
            const minY = Math.min(selectFirstCorner.y, selectSecondCorner.y);
            const maxX = Math.max(selectFirstCorner.x, selectSecondCorner.x);
            const maxY = Math.max(selectFirstCorner.y, selectSecondCorner.y);
            
            return x >= minX && x <= maxX && y >= minY && y <= maxY;
        }
        
        function deactivateSelectTool() {
            if (selectToolActive) {
                // If cells were moved and not yet finalized, place them at current position
                if (selectFirstCorner && selectSecondCorner && copiedCells && originalCellsCleared && (selectionOffsetX !== 0 || selectionOffsetY !== 0)) {
                    applySelection();
                }
                selectToolActive = false;
                selectFirstCorner = null;
                selectSecondCorner = null;
                previewSelectEnd = null; // Clear preview
                            drawGrid(); // Redraw to remove preview
                removeSelectionBox();
                selectionOffsetX = 0;
                selectionOffsetY = 0;
                originalCellsCleared = false;
                const selectButton = document.getElementById('selectButton');
                selectButton.classList.remove('active');
            }
        }
        
        function deactivatePasteMode() {
            if (pasteMode) {
                pasteMode = false;
                previewSelectEnd = null; // Clear selection preview
                const pasteButton = document.getElementById('pasteButton');
                pasteButton.classList.remove('active');
                drawGrid(); // Redraw to clear preview
            }
        }
        
        // Pattern Save/Load functions
        function savePattern() {
            if (!selectFirstCorner || !selectSecondCorner) return;
            
            const minX = Math.min(selectFirstCorner.x, selectSecondCorner.x);
            const minY = Math.min(selectFirstCorner.y, selectSecondCorner.y);
            const maxX = Math.max(selectFirstCorner.x, selectSecondCorner.x);
            const maxY = Math.max(selectFirstCorner.y, selectSecondCorner.y);
            
            // Store only living cells with their relative positions
            const patternCells = [];
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    if (grid[y][x] !== CELL_EMPTY) {
                        patternCells.push({
                            x: x - minX,
                            y: y - minY,
                            value: grid[y][x]
                        });
                    }
                }
            }
            
            if (patternCells.length === 0) {
                showCustomAlert('No living cells in selection to save!');
                return;
            }
            
            // Get current rule signature
            const signature = getCurrentRuleSignature();
            const ruleSets = getAllRuleSets();
            
            // Check if this rule set already exists
            let ruleSetName = findRuleSetBySignature(signature);
            
            if (ruleSetName) {
                // Rule set exists, just save the pattern
                showCustomPrompt('Saving Pattern', 'Enter a name for this pattern:', 'Pattern ' + (new Date().toLocaleTimeString()), (patternName) => {
                    if (!patternName) return;
                    
                    const pattern = {
                        name: patternName,
                        width: maxX - minX + 1,
                        height: maxY - minY + 1,
                        cells: patternCells,
                        timestamp: Date.now()
                    };
                    
                    ruleSets[ruleSetName].patterns.push(pattern);
                    
                    if (saveAllRuleSets(ruleSets)) {
                        showCustomAlert('Pattern "' + patternName + '" saved to "' + ruleSetName + '"!');
                    } else {
                        showCustomAlert('Failed to save pattern. Storage might be full.');
                    }
                });
            } else {
                // New rule set, prompt for name
                const currentRules = {
                    birthMin: BIRTH_MIN_NEIGHBORS,
                    birthMax: BIRTH_MAX_NEIGHBORS,
                    survivalMin: SURVIVAL_MIN_NEIGHBORS,
                    survivalMax: SURVIVAL_MAX_NEIGHBORS,
                    evolutionMin: EVOLUTION_MIN_NEIGHBORS,
                    evolutionMax: EVOLUTION_MAX_NEIGHBORS,
                    deathMin: DEATH_MIN_NEIGHBORS,
                    colorExpansion: COLOR_EXPANSION_RATE,
                    neighborsFight: neighborsFightEnabled,
                    movingCells: movingCellsEnabled
                };
                
                showCustomPrompt('New Rule Set Detected', 'Name this rule set:\n' + getRuleDescription(currentRules), 'Custom Rules ' + Object.keys(ruleSets).length, (newRuleSetName) => {
                    if (!newRuleSetName) return;
                    
                    // Check if name already exists
                    if (ruleSets[newRuleSetName]) {
                        showCustomAlert('Rule set name already exists. Please choose a different name.');
                        return;
                    }
                    
                    // Now prompt for pattern name
                    showCustomPrompt('Saving Pattern', 'Enter a name for this pattern:', 'Pattern ' + (new Date().toLocaleTimeString()), (patternName) => {
                        if (!patternName) return;
                        
                        const pattern = {
                            name: patternName,
                            width: maxX - minX + 1,
                            height: maxY - minY + 1,
                            cells: patternCells,
                            timestamp: Date.now()
                        };
                        
                        // Create new rule set
                        ruleSets[newRuleSetName] = {
                            signature: signature,
                            rules: currentRules,
                            patterns: [pattern],
                            created: Date.now()
                        };
                        
                        if (saveAllRuleSets(ruleSets)) {
                            showCustomAlert('Rule set "' + newRuleSetName + '" created!\nPattern "' + patternName + '" saved!');
                        } else {
                            showCustomAlert('Failed to save. Storage might be full.');
                        }
                    });
                });
            }
        }
        
        // Custom alert dialog
        function showCustomAlert(message) {
            const modal = document.getElementById('loadModal');
            const content = modal.querySelector('.load-modal-content');
            
            // Safety check
            if (!content) {
                console.error('Modal content not found');
                alert(message); // Fallback to native alert
                return;
            }
            
            // Store original content
            const originalContent = content.innerHTML;
            
            content.innerHTML = `
                <div class="load-modal-title">Notice</div>
                <div style="padding: 20px 0; text-align: center;">${message}</div>
                <button class="close-modal" id="alertOkButton">OK</button>
            `;
            modal.style.display = 'flex';
            
            // Restore original content when closed
            const okButton = document.getElementById('alertOkButton');
            okButton.onclick = () => {
                modal.style.display = 'none';
                content.innerHTML = originalContent;
                // Re-attach event listeners for the buttons
                reattachModalEventListeners();
            };
        }
        
        // Custom prompt dialog
        function showCustomPrompt(title, message, defaultValue, callback) {
            const modal = document.getElementById('loadModal');
            const content = modal.querySelector('.load-modal-content');
            
            // Store original content
            const originalContent = content.innerHTML;
            
            content.innerHTML = `
                <div class="load-modal-title">${title}</div>
                <div style="padding: 10px 0;">${message}</div>
                <input type="text" id="promptInput" value="${defaultValue}" style="width: 100%; padding: 10px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 5px; margin: 10px 0; font-size: 14px;">
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button class="close-modal" style="width: 50%;" id="promptCancelButton">Cancel</button>
                    <button class="close-modal" style="width: 50%; background: #2a6a2a;" id="promptOkButton">OK</button>
                </div>
            `;
            modal.style.display = 'flex';
            
            const input = document.getElementById('promptInput');
            input.focus();
            input.select();
            
            const cancelButton = document.getElementById('promptCancelButton');
            const okButton = document.getElementById('promptOkButton');
            
            const handleCancel = () => {
                modal.style.display = 'none';
                content.innerHTML = originalContent;
                reattachModalEventListeners();
            };
            
            const handleOk = () => {
                const value = input.value;
                modal.style.display = 'none';
                content.innerHTML = originalContent;
                reattachModalEventListeners();
                callback(value);
            };
            
            cancelButton.onclick = handleCancel;
            okButton.onclick = handleOk;
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleOk();
                }
            });
        }
        
        // Custom confirm dialog
        function showCustomConfirm(message, callback) {
            const modal = document.getElementById('loadModal');
            const content = modal.querySelector('.load-modal-content');
            
            // Store original content
            const originalContent = content.innerHTML;
            
            content.innerHTML = `
                <div class="load-modal-title">Confirm</div>
                <div style="padding: 20px 0; text-align: center;">${message}</div>
                <div style="display: flex; gap: 10px;">
                    <button class="close-modal" style="width: 50%;" id="confirmCancelButton">Cancel</button>
                    <button class="close-modal" style="width: 50%; background: #6a2a2a;" id="confirmOkButton">Delete</button>
                </div>
            `;
            modal.style.display = 'flex';
            
            const cancelButton = document.getElementById('confirmCancelButton');
            const okButton = document.getElementById('confirmOkButton');
            
            cancelButton.onclick = () => {
                modal.style.display = 'none';
                content.innerHTML = originalContent;
                reattachModalEventListeners();
            };
            
            okButton.onclick = () => {
                modal.style.display = 'none';
                content.innerHTML = originalContent;
                reattachModalEventListeners();
                callback();
            };
        }
        
        function loadPatternModal() {
            const modal = document.getElementById('loadModal');
            const patternsList = document.getElementById('savedPatternsList');
            
            const ruleSets = getAllRuleSets();
            const ruleSetNames = Object.keys(ruleSets);
            
            if (ruleSetNames.length === 0) {
                patternsList.innerHTML = '<div class="no-patterns-message">No saved patterns yet. Use the Select tool and Save button to save patterns!</div>';
            } else {
                patternsList.innerHTML = '';
                
                ruleSetNames.forEach(ruleSetName => {
                    const ruleSet = ruleSets[ruleSetName];
                    const patternCount = ruleSet.patterns.length;
                    
                    // Create rule set section
                    const section = document.createElement('div');
                    section.className = 'rule-set-section';
                    
                    // Create header
                    const header = document.createElement('div');
                    header.className = 'rule-set-header';
                    
                    const titleDiv = document.createElement('div');
                    titleDiv.style.flex = '1';
                    
                    const expandIcon = document.createElement('span');
                    expandIcon.className = 'expand-icon';
                    expandIcon.textContent = '‚ñ∂';
                    
                    const title = document.createElement('span');
                    title.className = 'rule-set-title';
                    title.textContent = ruleSetName;
                    
                    const info = document.createElement('div');
                    info.className = 'rule-set-info';
                    info.textContent = getRuleDescription(ruleSet.rules);
                    
                    titleDiv.appendChild(expandIcon);
                    titleDiv.appendChild(title);
                    titleDiv.appendChild(info);
                    
                    const count = document.createElement('span');
                    count.className = 'rule-set-count';
                    count.textContent = patternCount + (patternCount === 1 ? ' pattern' : ' patterns');
                    
                    const actions = document.createElement('div');
                    actions.className = 'rule-set-actions';
                    
                    const exportBtn = document.createElement('button');
                    exportBtn.className = 'rule-set-action-btn';
                    exportBtn.textContent = 'Export';
                    exportBtn.onclick = (e) => {
                        e.stopPropagation();
                        exportRuleSet(ruleSetName);
                    };
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'rule-set-action-btn';
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.style.background = '#6a2a2a';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        showCustomConfirm('Delete rule set "' + ruleSetName + '" and all ' + patternCount + ' patterns?', () => {
                            deleteRuleSet(ruleSetName);
                            loadPatternModal();
                        });
                    };
                    
                    actions.appendChild(exportBtn);
                    actions.appendChild(deleteBtn);
                    
                    header.appendChild(titleDiv);
                    header.appendChild(count);
                    header.appendChild(actions);
                    
                    // Create patterns container
                    const patternsContainer = document.createElement('div');
                    patternsContainer.className = 'rule-set-patterns';
                    
                    ruleSet.patterns.forEach((pattern, patternIndex) => {
                        const item = document.createElement('div');
                        item.className = 'saved-pattern-item';
                        
                        const patternInfo = document.createElement('div');
                        patternInfo.className = 'pattern-info';
                        
                        const name = document.createElement('div');
                        name.className = 'pattern-name';
                        name.textContent = pattern.name;
                        
                        const size = document.createElement('div');
                        size.className = 'pattern-size';
                        size.textContent = `${pattern.width}√ó${pattern.height} (${pattern.cells.length} cells)`;
                        
                        patternInfo.appendChild(name);
                        patternInfo.appendChild(size);
                        
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'pattern-delete';
                        deleteBtn.textContent = 'Delete';
                        deleteBtn.onclick = (e) => {
                            e.stopPropagation();
                            showCustomConfirm('Delete pattern "' + pattern.name + '"?', () => {
                                deletePattern(ruleSetName, patternIndex);
                                loadPatternModal();
                            });
                        };
                        
                        item.appendChild(patternInfo);
                        item.appendChild(deleteBtn);
                        
                        item.onclick = () => {
                            selectPatternForPaste(pattern);
                            modal.style.display = 'none';
                        };
                        
                        patternsContainer.appendChild(item);
                    });
                    
                    // Toggle expand/collapse
                    header.onclick = () => {
                        const isExpanded = patternsContainer.classList.contains('expanded');
                        if (isExpanded) {
                            patternsContainer.classList.remove('expanded');
                            expandIcon.classList.remove('expanded');
                        } else {
                            patternsContainer.classList.add('expanded');
                            expandIcon.classList.add('expanded');
                        }
                    };
                    
                    section.appendChild(header);
                    section.appendChild(patternsContainer);
                    patternsList.appendChild(section);
                });
            }
            
            modal.style.display = 'flex';
        }
        
        function exportRuleSet(ruleSetName) {
            const ruleSets = getAllRuleSets();
            const ruleSet = ruleSets[ruleSetName];
            
            const exportData = {
                name: ruleSetName,
                ruleSet: ruleSet,
                exportDate: new Date().toISOString()
            };
            
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = ruleSetName.replace(/[^a-z0-9]/gi, '-') + '.json';
            a.click();
            
            URL.revokeObjectURL(url);
        }
        
        function deleteRuleSet(ruleSetName) {
            const ruleSets = getAllRuleSets();
            delete ruleSets[ruleSetName];
            saveAllRuleSets(ruleSets);
        }
        
        function deletePattern(ruleSetName, patternIndex) {
            const ruleSets = getAllRuleSets();
            ruleSets[ruleSetName].patterns.splice(patternIndex, 1);
            
            // If no patterns left, delete the rule set
            if (ruleSets[ruleSetName].patterns.length === 0) {
                delete ruleSets[ruleSetName];
            }
            
            saveAllRuleSets(ruleSets);
        }
        
        function selectPatternForPaste(pattern) {
            // Convert pattern to copiedCells format
            copiedCells = {
                minX: 0,
                minY: 0,
                cells: pattern.cells
            };
            
            // Activate paste mode
            pasteMode = true;
            const pasteButton = document.getElementById('pasteButton');
            pasteButton.classList.add('active');
            
            // Deactivate select tool
            deactivateSelectTool();
        }
        
        function exportAllRuleSets() {
            const ruleSets = getAllRuleSets();
            
            if (Object.keys(ruleSets).length === 0) {
                showCustomAlert('No rule sets to export!');
                return;
            }
            
            const exportData = {
                ruleSets: ruleSets,
                exportDate: new Date().toISOString(),
                version: '1.0'
            };
            
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'GameOfLife-AllRuleSets-' + new Date().toISOString().split('T')[0] + '.json';
            a.click();
            
            URL.revokeObjectURL(url);
            
            showCustomAlert('All rule sets exported successfully!');
        }
        
        function importRuleSets(file) {
            const reader = new FileReader();
            
            reader.onload = (e) => {
                try {
                    const importData = JSON.parse(e.target.result);
                    
                    // Check if it's a single rule set or all rule sets
                    if (importData.ruleSet) {
                        // Single rule set import
                        const ruleSets = getAllRuleSets();
                        let importName = importData.name;
                        
                        // Check for name collision
                        let counter = 1;
                        while (ruleSets[importName]) {
                            importName = importData.name + ' (' + counter + ')';
                            counter++;
                        }
                        
                        ruleSets[importName] = importData.ruleSet;
                        
                        if (saveAllRuleSets(ruleSets)) {
                            // Close modal and show success message
                            document.getElementById('loadModal').style.display = 'none';
                            setTimeout(() => {
                                showCustomAlert('Rule set "' + importName + '" imported with ' + importData.ruleSet.patterns.length + ' patterns!\n\nClick Load Pattern button to view.');
                            }, 100);
                        } else {
                            showCustomAlert('Failed to import. Storage might be full.');
                        }
                    } else if (importData.ruleSets) {
                        // All rule sets import
                        const existingRuleSets = getAllRuleSets();
                        let importCount = 0;
                        
                        for (let ruleSetName in importData.ruleSets) {
                            let importName = ruleSetName;
                            let counter = 1;
                            
                            // Handle name collisions
                            while (existingRuleSets[importName]) {
                                importName = ruleSetName + ' (' + counter + ')';
                                counter++;
                            }
                            
                            existingRuleSets[importName] = importData.ruleSets[ruleSetName];
                            importCount++;
                        }
                        
                        if (saveAllRuleSets(existingRuleSets)) {
                            // Close modal and show success message
                            document.getElementById('loadModal').style.display = 'none';
                            setTimeout(() => {
                                showCustomAlert('Imported ' + importCount + ' rule set(s) successfully!\n\nClick Load Pattern button to view.');
                            }, 100);
                        } else {
                            showCustomAlert('Failed to import. Storage might be full.');
                        }
                    } else {
                        showCustomAlert('Invalid import file format.');
                    }
                } catch (error) {
                    showCustomAlert('Error reading file: ' + error.message);
                }
            };
            
            reader.readAsText(file);
        }
        
        // Save/Load functions
        function saveGame() {
            const gameState = {
                grid: grid,
                movingCells: movingCells,
                stagnationTimers: stagnationTimers,
                generation: generation,
                gridWidth: GRID_WIDTH,
                gridHeight: GRID_HEIGHT,
                rules: {
                    birthMin: BIRTH_MIN_NEIGHBORS,
                    birthMax: BIRTH_MAX_NEIGHBORS,
                    survivalMin: SURVIVAL_MIN_NEIGHBORS,
                    survivalMax: SURVIVAL_MAX_NEIGHBORS,
                    evolutionMin: EVOLUTION_MIN_NEIGHBORS,
                    evolutionMax: EVOLUTION_MAX_NEIGHBORS,
                    deathMin: DEATH_MIN_NEIGHBORS,
                    colorExpansion: COLOR_EXPANSION_RATE
                },
                settings: {
                    speed: parseInt(document.getElementById('speed').value),
                    selectedColor: selectedColor,
                    zoomLevel: zoomLevel,
                    viewOffsetX: viewOffsetX,
                    viewOffsetY: viewOffsetY,
                    movingCellsEnabled: movingCellsEnabled,
                    neighborsFightEnabled: neighborsFightEnabled
                }
            };
            
            const jsonStr = JSON.stringify(gameState);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'game-of-life-pro-save.json';
            a.click();
            
            URL.revokeObjectURL(url);
        }
        
        function loadGame() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const gameState = JSON.parse(event.target.result);
                        
                        // Restore grid
                        GRID_WIDTH = gameState.gridWidth;
                        GRID_HEIGHT = gameState.gridHeight;
                        grid = gameState.grid;
                        movingCells = gameState.movingCells || [];
                        stagnationTimers = gameState.stagnationTimers || [];
                        generation = gameState.generation || 0;
                        
                        // Restore rules
                        BIRTH_MIN_NEIGHBORS = gameState.rules.birthMin;
                        BIRTH_MAX_NEIGHBORS = gameState.rules.birthMax;
                        SURVIVAL_MIN_NEIGHBORS = gameState.rules.survivalMin;
                        SURVIVAL_MAX_NEIGHBORS = gameState.rules.survivalMax;
                        EVOLUTION_MIN_NEIGHBORS = gameState.rules.evolutionMin;
                        EVOLUTION_MAX_NEIGHBORS = gameState.rules.evolutionMax;
                        DEATH_MIN_NEIGHBORS = gameState.rules.deathMin;
                        COLOR_EXPANSION_RATE = gameState.rules.colorExpansion;
                        
                        // Update UI for rules
                        document.getElementById('birthMin').value = BIRTH_MIN_NEIGHBORS;
                        document.getElementById('birthMax').value = BIRTH_MAX_NEIGHBORS;
                        document.getElementById('birthMinValue').textContent = BIRTH_MIN_NEIGHBORS;
                        document.getElementById('birthMaxValue').textContent = BIRTH_MAX_NEIGHBORS;
                        
                        document.getElementById('survivalMin').value = SURVIVAL_MIN_NEIGHBORS;
                        document.getElementById('survivalMax').value = SURVIVAL_MAX_NEIGHBORS;
                        document.getElementById('survivalMinValue').textContent = SURVIVAL_MIN_NEIGHBORS;
                        document.getElementById('survivalMaxValue').textContent = SURVIVAL_MAX_NEIGHBORS;
                        
                        document.getElementById('evolutionMin').value = EVOLUTION_MIN_NEIGHBORS;
                        document.getElementById('evolutionMax').value = EVOLUTION_MAX_NEIGHBORS;
                        document.getElementById('evolutionMinValue').textContent = EVOLUTION_MIN_NEIGHBORS;
                        document.getElementById('evolutionMaxValue').textContent = EVOLUTION_MAX_NEIGHBORS;
                        
                        document.getElementById('deathMin').value = DEATH_MIN_NEIGHBORS;
                        document.getElementById('deathMinValue').textContent = DEATH_MIN_NEIGHBORS;
                        
                        document.getElementById('colorExpansionRate').value = COLOR_EXPANSION_RATE;
                        document.getElementById('colorExpansionValue').textContent = COLOR_EXPANSION_RATE;
                        
                        // Restore settings
                        if (gameState.settings) {
                            document.getElementById('speed').value = gameState.settings.speed;
                            document.getElementById('speedValue').textContent = gameState.settings.speed;
                            selectedColor = gameState.settings.selectedColor;
                            zoomLevel = gameState.settings.zoomLevel;
                            viewOffsetX = gameState.settings.viewOffsetX;
                            viewOffsetY = gameState.settings.viewOffsetY;
                            movingCellsEnabled = gameState.settings.movingCellsEnabled;
                            neighborsFightEnabled = gameState.settings.neighborsFightEnabled;
                            
                            // Update UI
                            document.querySelectorAll('.color-swatch').forEach((swatch) => {
                                swatch.classList.toggle('active', parseInt(swatch.dataset.color) === selectedColor);
                            });
                            
                            document.getElementById('toggleMovingCells').textContent = 
                                movingCellsEnabled ? 'Moving Cells: ON' : 'Moving Cells: OFF';
                            document.getElementById('toggleMovingCells').classList.toggle('active', movingCellsEnabled);
                            
                            document.getElementById('toggleNeighborsFight').textContent = 
                                neighborsFightEnabled ? 'Neighbors Fight: ON' : 'Neighbors Fight: OFF';
                            document.getElementById('toggleNeighborsFight').classList.toggle('active', neighborsFightEnabled);
                        }
                        
                        // Update canvas size selectors
                        document.getElementById('canvasWidth').value = GRID_WIDTH;
                        document.getElementById('canvasHeight').value = GRID_HEIGHT;
                        
                        // Pause game if playing
                        if (isPlaying) {
                            isPlaying = false;
                            document.getElementById('playPause').textContent = '‚ñ∂ Play';
                        }
                        
                        // Reinitialize canvas
                        resizeCanvas();
                        document.getElementById('generation').textContent = generation;
                        document.getElementById('zoomDisplay').textContent = zoomLevel.toFixed(2) + 'x';
                        drawGrid();
                        
                    } catch (error) {
                        alert('Error loading save file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        // Color swatch selection
        document.querySelectorAll('.color-swatch').forEach(button => {
            button.addEventListener('click', function() {
                // Deactivate zoom and eraser when color is selected (but keep shape tools active)
                deactivateZoom();
                deactivateEraser();
                deactivateSelectTool();
                deactivatePasteMode();
                
                // Remove active class from all swatches
                document.querySelectorAll('.color-swatch').forEach(b => b.classList.remove('active'));
                // Add active class to clicked swatch
                this.classList.add('active');
                // Set selected color
                selectedColor = parseInt(this.getAttribute('data-color'));
                previousColor = selectedColor; // Update previous color
            });
        });
        
        // Eraser button (now a simple tool button)
        document.getElementById('eraserButton').addEventListener('click', function() {
            // Deactivate zoom and all drawing tools when eraser is clicked
            deactivateZoom();
            deactivateLineTool();
            deactivateRectangleTool();
            deactivateOvalTool();
            deactivateSelectTool();
            deactivatePasteMode();
            
            // Toggle eraser mode
            eraserMode = !eraserMode;
            
            if (!eraserMode) {
                // Deactivate eraser
                eraserSize = 0;
                eraserCursorPos = null;
                canvas.classList.remove('eraser-cursor');
                this.classList.remove('active');
                
                // Reactivate the previous color swatch
                const previousColorSwatch = document.querySelector(`.color-swatch[data-color="${previousColor}"]`);
                if (previousColorSwatch) {
                    previousColorSwatch.classList.add('active');
                }
                selectedColor = previousColor;
                drawGrid();
            } else {
                // Activate eraser with default size
                previousColor = selectedColor;
                eraserSize = 2; // Use medium size (25x25)
                eraserMode = true;
                // Remove active from all color swatches
                document.querySelectorAll('.color-swatch').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
            }
        });
        
        document.getElementById('speed').addEventListener('input', (e) => {
            SPEED = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = SPEED;
        });
        
        // Birth rule sliders
        document.getElementById('birthMin').addEventListener('input', (e) => {
            deactivateZoom();
            let newMin = parseInt(e.target.value);
            if (newMin > BIRTH_MAX_NEIGHBORS) {
                newMin = BIRTH_MAX_NEIGHBORS;
                e.target.value = newMin;
                
                // Highlight the max value that's capping us
                const birthMaxValue = document.getElementById('birthMaxValue');
                birthMaxValue.classList.add('capped-highlight');
                setTimeout(() => {
                    birthMaxValue.classList.remove('capped-highlight');
                }, 500);
            }
            BIRTH_MIN_NEIGHBORS = newMin;
            document.getElementById('birthMinValue').textContent = newMin;
        });
        
        document.getElementById('birthMax').addEventListener('input', (e) => {
            deactivateZoom();
            let newMax = parseInt(e.target.value);
            if (newMax < BIRTH_MIN_NEIGHBORS) {
                newMax = BIRTH_MIN_NEIGHBORS;
                e.target.value = newMax;
                
                // Highlight the min value that's capping us
                const birthMinValue = document.getElementById('birthMinValue');
                birthMinValue.classList.add('capped-highlight');
                setTimeout(() => {
                    birthMinValue.classList.remove('capped-highlight');
                }, 500);
            }
            BIRTH_MAX_NEIGHBORS = newMax;
            document.getElementById('birthMaxValue').textContent = newMax;
        });
        
        // Survival rule sliders
        document.getElementById('survivalMin').addEventListener('input', (e) => {
            deactivateZoom();
            let newMin = parseInt(e.target.value);
            if (newMin > SURVIVAL_MAX_NEIGHBORS) {
                newMin = SURVIVAL_MAX_NEIGHBORS;
                e.target.value = newMin;
                
                // Highlight the max value that's capping us
                const survivalMaxValue = document.getElementById('survivalMaxValue');
                survivalMaxValue.classList.add('capped-highlight');
                setTimeout(() => {
                    survivalMaxValue.classList.remove('capped-highlight');
                }, 500);
            }
            SURVIVAL_MIN_NEIGHBORS = newMin;
            document.getElementById('survivalMinValue').textContent = newMin;
        });
        
        document.getElementById('survivalMax').addEventListener('input', (e) => {
            deactivateZoom();
            let newMax = parseInt(e.target.value);
            let wasCapped = false;
            
            if (newMax < SURVIVAL_MIN_NEIGHBORS) {
                newMax = SURVIVAL_MIN_NEIGHBORS;
                e.target.value = newMax;
                
                // Highlight the min value that's capping us
                const survivalMinValue = document.getElementById('survivalMinValue');
                survivalMinValue.classList.add('capped-highlight');
                setTimeout(() => {
                    survivalMinValue.classList.remove('capped-highlight');
                }, 500);
            }
            // Survival max cannot exceed death threshold
            if (newMax >= DEATH_MIN_NEIGHBORS) {
                newMax = DEATH_MIN_NEIGHBORS - 1;
                e.target.value = newMax;
                wasCapped = true;
                
                // Highlight the death value that's capping us
                const deathValue = document.getElementById('deathMinValue');
                deathValue.classList.add('capped-highlight');
                setTimeout(() => {
                    deathValue.classList.remove('capped-highlight');
                }, 500);
            }
            
            SURVIVAL_MAX_NEIGHBORS = newMax;
            document.getElementById('survivalMaxValue').textContent = newMax;
        });
        
        // Evolution rule sliders
        document.getElementById('evolutionMin').addEventListener('input', (e) => {
            deactivateZoom();
            let newMin = parseInt(e.target.value);
            if (newMin > EVOLUTION_MAX_NEIGHBORS) {
                newMin = EVOLUTION_MAX_NEIGHBORS;
                e.target.value = newMin;
                
                // Highlight the max value that's capping us
                const evolutionMaxValue = document.getElementById('evolutionMaxValue');
                evolutionMaxValue.classList.add('capped-highlight');
                setTimeout(() => {
                    evolutionMaxValue.classList.remove('capped-highlight');
                }, 500);
            }
            EVOLUTION_MIN_NEIGHBORS = newMin;
            document.getElementById('evolutionMinValue').textContent = newMin;
        });
        
        document.getElementById('evolutionMax').addEventListener('input', (e) => {
            deactivateZoom();
            let newMax = parseInt(e.target.value);
            if (newMax < EVOLUTION_MIN_NEIGHBORS) {
                newMax = EVOLUTION_MIN_NEIGHBORS;
                e.target.value = newMax;
                
                // Highlight the min value that's capping us
                const evolutionMinValue = document.getElementById('evolutionMinValue');
                evolutionMinValue.classList.add('capped-highlight');
                setTimeout(() => {
                    evolutionMinValue.classList.remove('capped-highlight');
                }, 500);
            }
            EVOLUTION_MAX_NEIGHBORS = newMax;
            document.getElementById('evolutionMaxValue').textContent = newMax;
            
            // Update death minimum to stay above evolution max
            if (DEATH_MIN_NEIGHBORS <= newMax) {
                DEATH_MIN_NEIGHBORS = newMax + 1;
                document.getElementById('deathMin').value = DEATH_MIN_NEIGHBORS;
                document.getElementById('deathMinValue').textContent = DEATH_MIN_NEIGHBORS;
            }
        });
        
        // Death rule slider
        document.getElementById('deathMin').addEventListener('input', (e) => {
            deactivateZoom();
            let newMin = parseInt(e.target.value);
            
            // Death must be above evolution max
            if (newMin <= EVOLUTION_MAX_NEIGHBORS) {
                newMin = EVOLUTION_MAX_NEIGHBORS + 1;
                e.target.value = newMin;
                
                // Highlight the evolution value that's capping us
                const evolutionValue = document.getElementById('evolutionMaxValue');
                evolutionValue.classList.add('capped-highlight');
                setTimeout(() => {
                    evolutionValue.classList.remove('capped-highlight');
                }, 500);
            }
            // Death must be above survival max
            else if (newMin <= SURVIVAL_MAX_NEIGHBORS) {
                newMin = SURVIVAL_MAX_NEIGHBORS + 1;
                e.target.value = newMin;
                
                // Highlight the survival value that's capping us
                const survivalValue = document.getElementById('survivalMaxValue');
                survivalValue.classList.add('capped-highlight');
                setTimeout(() => {
                    survivalValue.classList.remove('capped-highlight');
                }, 500);
            }
            
            DEATH_MIN_NEIGHBORS = newMin;
            document.getElementById('deathMinValue').textContent = newMin;
        });
        
        // Reset all rules to default values
        document.getElementById('resetRulesToDefault').addEventListener('click', function() {
            deactivateZoom();
            
            // Birth: 3-3
            BIRTH_MIN_NEIGHBORS = 3;
            BIRTH_MAX_NEIGHBORS = 3;
            document.getElementById('birthMin').value = 3;
            document.getElementById('birthMax').value = 3;
            document.getElementById('birthMinValue').textContent = 3;
            document.getElementById('birthMaxValue').textContent = 3;
            
            // Survival: 2-3
            SURVIVAL_MIN_NEIGHBORS = 2;
            SURVIVAL_MAX_NEIGHBORS = 3;
            document.getElementById('survivalMin').value = 2;
            document.getElementById('survivalMax').value = 3;
            document.getElementById('survivalMinValue').textContent = 2;
            document.getElementById('survivalMaxValue').textContent = 3;
            
            // Evolution: 4-4
            EVOLUTION_MIN_NEIGHBORS = 4;
            EVOLUTION_MAX_NEIGHBORS = 4;
            document.getElementById('evolutionMin').value = 4;
            document.getElementById('evolutionMax').value = 4;
            document.getElementById('evolutionMinValue').textContent = 4;
            document.getElementById('evolutionMaxValue').textContent = 4;
            
            // Death: 5+
            DEATH_MIN_NEIGHBORS = 5;
            document.getElementById('deathMin').value = 5;
            document.getElementById('deathMinValue').textContent = 5;
            
            // Color Expansion Rate: 100
            COLOR_EXPANSION_RATE = 100;
            document.getElementById('colorExpansionRate').value = 100;
            document.getElementById('colorExpansionValue').textContent = 100;
        });
        
        // Size preset buttons removed - mobile size is auto-detected
        
        document.getElementById('applyCanvasSize').addEventListener('click', function() {
            deactivateZoom();
            const newWidth = parseInt(document.getElementById('canvasWidth').value);
            const newHeight = parseInt(document.getElementById('canvasHeight').value);
            
            GRID_WIDTH = newWidth;
            GRID_HEIGHT = newHeight;
            
            // Reset zoom to 1 if current zoom is below new minimum
            const minZoom = getMinZoomLevel();
            if (zoomLevel < minZoom) {
                zoomLevel = 1;
                viewOffsetX = 0;
                viewOffsetY = 0;
            }
            
            initGrid();
            resizeCanvas();
            drawGrid();
        });
        
        // Detect mobile device and set canvas to 100x150
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                || (window.innerWidth <= 768);
        }
        
        // Set mobile flag and hide load pattern button on mobile
        isMobile = isMobileDevice();
        if (isMobile) {
            GRID_WIDTH = 100;
            GRID_HEIGHT = 150;
            document.getElementById('canvasWidth').value = '100';
            document.getElementById('canvasHeight').value = '150';
            
            // Hide load pattern button on mobile
            const loadPatternBtn = document.getElementById('loadPatternButton');
            if (loadPatternBtn) {
                loadPatternBtn.style.display = 'none';
            }
        }
        
        // Initialize
        initGrid();
        resizeCanvas();
        drawGrid();
    </script>
</body>
</html>