<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <title>Evolving Color Life - Stagnation Version</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #111;
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            -webkit-text-size-adjust: 100%; /* Prevent text size adjustment on mobile */
        }
        
        * {
            box-sizing: border-box;
        }
        
        h1 {
            margin: 0 0 20px 0;
            font-size: 24px;
            color: #fff;
        }
        
        #canvas {
            border: 2px solid #333;
            cursor: crosshair;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none; /* Prevent default touch behaviors like scrolling */
            -webkit-user-select: none; /* Prevent text selection on touch */
            user-select: none;
        }
        
        #canvas.eraser-cursor {
            cursor: none; /* Hide default cursor when using eraser */
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }
        
        .color-palette {
            margin: 15px 0;
            display: flex;
            gap: 6px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .color-swatch {
            width: 35px;
            height: 35px;
            border: 3px solid #444;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }
        
        .color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        
        .color-swatch.active {
            border: 3px solid #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.6);
            transform: scale(1.15);
        }
        
        .tool-button {
            width: 35px;
            height: 35px;
            border: 3px solid #444;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            flex-shrink: 0;
            background: #2a2a2a;
            color: #fff;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            min-height: unset;
        }
        
        .tool-button:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            background: #3a3a3a;
        }
        
        .tool-button.active {
            border: 3px solid #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.6);
            transform: scale(1.15);
            background: #4a4a4a;
        }
        
        button {
            padding: 10px 20px;
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
            min-height: 44px; /* iOS minimum recommended touch target */
        }
        
        button:hover {
            background: #3a3a3a;
        }
        
        button:active {
            background: #1a1a1a;
        }
        
        button.active {
            background: #4a4a4a;
            border-color: #666;
        }
        
        .info {
            margin: 20px 0;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            max-width: 800px;
            line-height: 1.6;
        }
        
        .canvas-info {
            margin-top: 5px;
            font-size: 11px;
            color: #fff;
            text-align: left;
        }
        
        .color-button {
            padding: 6px 10px;
            background: #2a2a2a;
            color: #fff;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
            font-family: 'Segoe UI', system-ui, sans-serif;
            min-width: 190px; /* Fixed minimum width to prevent shifting */
            justify-content: flex-start;
            white-space: nowrap;
        }
        
        .color-button:hover {
            background: #3a3a3a;
            border-color: #666;
        }
        
        .color-button.active {
            background: #4a4a4a;
            border-color: #888;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        
        select, input[type="range"] {
            padding: 5px;
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
        }
        
        select {
            min-width: 80px;
            font-size: 14px;
        }
        
        select option {
            background: #2a2a2a;
            color: #fff;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .rules-section {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            max-width: 800px;
        }
        
        .rule-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            gap: 8px;
        }
        
        .rule-title {
            font-weight: bold;
            font-size: 14px;
            color: #fff;
            margin: 0;
        }
        
        .rule-sliders {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .rule-sliders .slider-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .rule-sliders input[type="range"] {
            width: 100px;
        }
        
        .capped-highlight {
            color: #ff6b6b !important;
            font-weight: bold;
            animation: pulse 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        /* Mobile-specific styles */
        @media (max-width: 480px) {
            .color-swatch, .tool-button {
                width: 30px;
                height: 30px;
                border: 2px solid #444;
            }
            
            .color-swatch.active, .tool-button.active {
                border: 2px solid #fff;
            }
            
            .color-palette {
                gap: 4px;
            }
        }
    </style>
</head>
<body>
    <h1>-The Game of Life Pro-</h1>
    
    <canvas id="canvas"></canvas>
    <div class="canvas-info">
        Generation: <span id="generation">0</span> | Zoom: <span id="zoomDisplay">1.00x</span> | Tools/Settings ‚¨áÔ∏è
    </div>
    
    <!-- Color Palette Row -->
    <div class="color-palette">
        <button class="color-swatch active" data-color="1" id="colorWhite" style="background: white; border: 2px solid #666;"></button>
        <button class="color-swatch" data-color="2" id="colorRed" style="background: #ff0000;"></button>
        <button class="color-swatch" data-color="3" id="colorOrange" style="background: #ff8800;"></button>
        <button class="color-swatch" data-color="4" id="colorYellow" style="background: #ffff00;"></button>
        <button class="color-swatch" data-color="5" id="colorGreen" style="background: #00ff00;"></button>
        <button class="color-swatch" data-color="6" id="colorCyan" style="background: #00ffff;"></button>
        <button class="color-swatch" data-color="7" id="colorBlue" style="background: #0088ff;"></button>
        <button class="color-swatch" data-color="8" id="colorPurple" style="background: #8800ff;"></button>
        <button class="color-swatch" data-color="9" id="colorMagenta" style="background: #ff00ff;"></button>
        <button class="tool-button" id="lineToolButton" title="Line Tool">‚ï±</button>
        <button class="tool-button" id="rectangleToolButton" title="Rectangle Tool">‚ñ¢</button>
        <button class="tool-button" id="ovalToolButton" title="Oval Tool">‚¨≠</button>
        <button class="tool-button" id="randomButton" title="Random">üé≤</button>
    </div>
    
    <!-- Row 1: Play/Pause, Step, Clear, Eraser, Zoom -->
    <div class="controls">
        <button id="playPause">‚ñ∂ Play</button>
        <button id="step">Step</button>
        <button id="clear">Clear</button>
        <button class="color-button" id="eraserButton">
            <span style="font-size: 16px;">üóëÔ∏è</span> Eraser
        </button>
        <button id="zoomButton">Zoom: OFF</button>
    </div>
    
    <!-- Row 2: Speed, Neighbors Fight, Moving Cells -->
    <div class="controls">
        <div class="slider-container">
            <label>Speed:</label>
            <input type="range" id="speed" min="1" max="30" value="20">
            <span id="speedValue">20</span>
        </div>
        <button id="toggleNeighborsFight" class="active">Neighbors Fight: ON</button>
        <button id="toggleMovingCells" class="active">Moving Cells: ON</button>
    </div>
    
    <!-- Row 3: Color Expansion Slider -->
    <div class="controls">
        <div class="slider-container">
            <label>Color Expansion (every 1-300 steps):</label>
            <input type="range" id="colorExpansionRate" min="1" max="300" value="100">
            <span id="colorExpansionValue">100</span>
        </div>
    </div>
    
    <!-- Row 4: Custom Canvas Settings -->
    <div class="controls">
        <label>Canvas Size (desktop only):</label>
        <div class="slider-container">
            <label>Width:</label>
            <select id="canvasWidth">
                <option value="50">50</option>
                <option value="75">75</option>
                <option value="100">100</option>
                <option value="150">150</option>
                <option value="200" selected>200</option>
                <option value="250">250</option>
                <option value="300">300</option>
                <option value="400">400</option>
                <option value="500">500</option>
            </select>
        </div>
        <div class="slider-container">
            <label>Height:</label>
            <select id="canvasHeight">
                <option value="50">50</option>
                <option value="75">75</option>
                <option value="100">100</option>
                <option value="150" selected>150</option>
                <option value="175">175</option>
                <option value="200">200</option>
                <option value="250">250</option>
                <option value="300">300</option>
                <option value="400">400</option>
                <option value="500">500</option>
            </select>
        </div>
        <button id="applyCanvasSize">Apply Size</button>
    </div>
    
    <!-- Cellular Automaton Rules Section -->
    <div class="controls">
        <label>Cellular Automaton Rules:</label>
    </div>
    
    <div class="rules-section">
        <!-- Birth Rule -->
        <div class="rule-group">
            <div class="rule-title">Birth (Neighbors):</div>
            <div class="rule-sliders">
                <div class="slider-container">
                    <label>Min:</label>
                    <input type="range" id="birthMin" min="0" max="8" value="3">
                    <span id="birthMinValue">3</span>
                </div>
                <div class="slider-container">
                    <label>Max:</label>
                    <input type="range" id="birthMax" min="0" max="8" value="3">
                    <span id="birthMaxValue">3</span>
                </div>
            </div>
        </div>
        
        <!-- Survival Rule -->
        <div class="rule-group">
            <div class="rule-title">Survival (Neighbors):</div>
            <div class="rule-sliders">
                <div class="slider-container">
                    <label>Min:</label>
                    <input type="range" id="survivalMin" min="0" max="8" value="2">
                    <span id="survivalMinValue">2</span>
                </div>
                <div class="slider-container">
                    <label>Max:</label>
                    <input type="range" id="survivalMax" min="0" max="8" value="3">
                    <span id="survivalMaxValue">3</span>
                </div>
            </div>
        </div>
        
        <!-- Evolution Rule -->
        <div class="rule-group">
            <div class="rule-title">Evolution (Neighbors):</div>
            <div class="rule-sliders">
                <div class="slider-container">
                    <label>Min:</label>
                    <input type="range" id="evolutionMin" min="1" max="8" value="4">
                    <span id="evolutionMinValue">4</span>
                </div>
                <div class="slider-container">
                    <label>Max:</label>
                    <input type="range" id="evolutionMax" min="1" max="8" value="4">
                    <span id="evolutionMaxValue">4</span>
                </div>
            </div>
        </div>
        
        <!-- Death Rule -->
        <div class="rule-group">
            <div class="rule-title">Death (Overpopulation):</div>
            <div class="rule-sliders">
                <div class="slider-container">
                    <label>At:</label>
                    <input type="range" id="deathMin" min="1" max="8" value="5">
                    <span id="deathMinValue">5</span>
                    <span style="margin-left: 5px;">+ neighbors</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button id="resetRulesToDefault">Reset Rules to Default</button>
    </div>
    
    <div class="info">
        <h3>Game Rules:</h3>
        <ul>
            <li><strong>Birth:</strong> Empty cells with 3 neighbors of a color are born as that color (default: 3-3, adjustable)</li>
            <li><strong>Survival:</strong> Cells with 2-3 neighbors survive (default: 2-3, adjustable)</li>
            <li><strong>Death:</strong> Cells die with &lt;2 neighbors (isolation) or 5+ neighbors (overpopulation, default: 5+, adjustable)</li>
            <li><strong>Evolution:</strong> Cells with 4 neighbors evolve to next color (default: 4-4, adjustable)</li>
            <li><strong>Magenta Special:</strong> Magenta cells in evolution range spawn moving white spore then die (with Moving Cells ON) or evolve to white (OFF)</li>
            <li><strong>Color Expansion Rate:</strong> Controls stagnation threshold (1-300 generations, default: 100). Affects both Moving Cells spawning and Neighbors Fight conversion speed. Lower = faster action, higher = more stability.</li>
            <li><strong>Moving Cells (Toggleable):</strong> When ON, stagnant cells (3+ same-color neighbors unchanged for Color Expansion Rate) spawn moving cells. Moving cells travel outward (70% straight/30% turn), pass through other movers, and after 4+ frames: stop on same color or convert entire groups of different colors.</li>
            <li><strong>Neighbors Fight (Toggleable):</strong> When ON, stagnant cells of a higher-color will convert adjacent lower-colored neighbors. This occurs based on the Color Expansion Rate (1-300 steps). This can break stagnation and create color battles or territory expansion.</li>
            <li><strong>Color Hierarchy:</strong> White ‚Üí Red ‚Üí Orange ‚Üí Yellow ‚Üí Green ‚Üí Cyan ‚Üí Blue ‚Üí Purple ‚Üí Magenta ‚Üí (spawns White spore)</li>
        </ul>
        <h3>Drawing Tools:</h3>
        <ul>
            <li><strong>Color Selection:</strong> Click any color swatch above the controls to select a drawing color, then click/drag on canvas to draw cells</li>
            <li><strong>Eraser:</strong> Cycles through 5x5 ‚Üí 25x25 ‚Üí 51x51 ‚Üí OFF. Red circle shows eraser size, fills when actively erasing</li>
            <li><strong>Line Tool:</strong> Click start point, move mouse (red preview line), click end point to draw straight line</li>
            <li><strong>Rectangle Tool:</strong> Click corner, move mouse (red preview box), click opposite corner to draw rectangle outline</li>
            <li><strong>Oval Tool:</strong> Click corner, move mouse (red preview ellipse), click opposite corner to draw oval outline</li>
            <li><strong>Zoom:</strong> Cycles through OFF ‚Üí IN (click to zoom in) ‚Üí OUT (click to zoom out) ‚Üí OFF. Auto-limited to prevent black space based on canvas size.</li>
            <li><strong>Canvas Size:</strong> Custom width/height with dropdowns (50-500 cells). Click "Apply Size" to rebuild grid. Mobile devices auto-detect and use 100x150.</li>
        </ul>
        <p><strong>Tip:</strong> Try Color Expansion Rate at 50 for fast chaos, 200 for slow evolution! Combine Neighbors Fight + Moving Cells for epic color battles!</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Configuration
        let CELL_SIZE = 4;
        let GRID_WIDTH = 200;
        let GRID_HEIGHT = 150;
        let SPEED = 20;
        
        // Rule parameters (adjustable)
        let BIRTH_MIN_NEIGHBORS = 3;
        let BIRTH_MAX_NEIGHBORS = 3;
        let SURVIVAL_MIN_NEIGHBORS = 2;
        let SURVIVAL_MAX_NEIGHBORS = 3;
        let EVOLUTION_MIN_NEIGHBORS = 4;
        let EVOLUTION_MAX_NEIGHBORS = 4;
        let DEATH_MIN_NEIGHBORS = 5; // Death occurs at this many neighbors or more
        let COLOR_EXPANSION_RATE = 100; // Rate for stagnant cell spawning/neighbor fighting
        
        // Cell states
        const CELL_EMPTY = 0;
        const CELL_WHITE = 1;
        const CELL_WHITE_MOVING = 10; // Special state for moving white cells
        
        // Color hierarchy
        const COLORS = [
            '#000000', // 0: Empty
            '#ffffff', // 1: White
            '#ff0000', // 2: Red
            '#ff8800', // 3: Orange
            '#ffff00', // 4: Yellow
            '#00ff00', // 5: Green
            '#00ffff', // 6: Cyan
            '#0088ff', // 7: Blue
            '#8800ff', // 8: Purple
            '#ff00ff'  // 9: Magenta
        ];
        
        // Grid state
        let grid = [];
        let movingCells = []; // Track moving white cells {x, y, dx, dy}
        let stagnationTimers = []; // Track frames since last change for each cell
        let generation = 0;
        let isPlaying = false;
        let mouseDown = false;
        let lastCell = null;
        let lastUpdate = 0;
        let selectedColor = 1; // Currently selected color for drawing (default: white)
        let eraserMode = false; // Track if eraser is active
        let previousColor = 1; // Track color before eraser was activated
        let zoomLevel = 1; // Zoom level (1 = normal, 2 = 2x zoom, etc)
        let viewOffsetX = 0; // Viewport offset for panning when zoomed
        let viewOffsetY = 0;
        let movingCellsEnabled = true; // Toggle for moving cells feature
        let neighborsFightEnabled = true; // Toggle for neighbors fight feature (ON by default)
        let zoomMode = 0; // 0 = normal, 1 = zoom in mode, 2 = zoom out mode
        let lineToolActive = false; // Toggle for line drawing tool
        let lineStartPoint = null; // First point of line
        let previewLineEnd = null; // Current mouse position for line preview
        let rectangleToolActive = false; // Toggle for rectangle drawing tool
        let rectangleStartPoint = null; // First point of rectangle
        let previewRectangleEnd = null; // Current mouse position for rectangle preview
        let ovalToolActive = false; // Toggle for oval drawing tool
        let ovalStartPoint = null; // First point of oval
        let previewOvalEnd = null; // Current mouse position for oval preview
        let eraserCursorPos = null; // Track mouse position for eraser cursor {x, y} in grid coords
        let eraserSize = 0; // 0 = off, 1 = 5x5 (radius 2.5), 2 = 25x25 (radius 12.5), 3 = 51x51 (radius 25.5)
        let eraserActive = false; // Track if eraser is currently being used (mouse/touch down)
        
        // Erase cells in a circular area based on eraser size
        function eraseCircularArea(x, y) {
            let radius;
            if (eraserSize === 1) {
                radius = 2.5;
            } else if (eraserSize === 2) {
                radius = 12.5;
            } else if (eraserSize === 3) {
                radius = 25.5;
            } else {
                return; // No erasing if eraserSize is 0
            }
            
            const minX = Math.floor(x - radius);
            const maxX = Math.ceil(x + radius);
            const minY = Math.floor(y - radius);
            const maxY = Math.ceil(y + radius);
            
            for (let dy = minY; dy <= maxY; dy++) {
                for (let dx = minX; dx <= maxX; dx++) {
                    const distance = Math.sqrt((dx - x) * (dx - x) + (dy - y) * (dy - y));
                    if (distance <= radius) {
                        const nx = dx;
                        const ny = dy;
                        if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                            grid[ny][nx] = 0;
                        }
                    }
                }
            }
            
            // Also remove any moving cells in the eraser area
            movingCells = movingCells.filter(cell => {
                const dx = cell.x - x;
                const dy = cell.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance > radius;
            });
        }
        
        // Initialize grid
        function initGrid() {
            grid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
            stagnationTimers = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
            movingCells = [];
        }
        
        // Resize canvas
        function resizeCanvas() {
            canvas.width = GRID_WIDTH * CELL_SIZE;
            canvas.height = GRID_HEIGHT * CELL_SIZE;
        }
        
        // Draw grid
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate visible grid area based on zoom
            const cellsVisibleX = Math.ceil(GRID_WIDTH / zoomLevel);
            const cellsVisibleY = Math.ceil(GRID_HEIGHT / zoomLevel);
            
            // Clamp view offset to grid bounds
            viewOffsetX = Math.max(0, Math.min(viewOffsetX, GRID_WIDTH - cellsVisibleX));
            viewOffsetY = Math.max(0, Math.min(viewOffsetY, GRID_HEIGHT - cellsVisibleY));
            
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            
            // Draw regular cells
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    // Only draw cells in visible viewport
                    if (x >= viewOffsetX && x < viewOffsetX + cellsVisibleX &&
                        y >= viewOffsetY && y < viewOffsetY + cellsVisibleY) {
                        
                        const cell = grid[y][x];
                        if (cell > 0 && cell < 10) {
                            ctx.fillStyle = COLORS[cell];
                            const screenX = (x - viewOffsetX) * effectiveCellSize;
                            const screenY = (y - viewOffsetY) * effectiveCellSize;
                            ctx.fillRect(screenX, screenY, effectiveCellSize, effectiveCellSize);
                        }
                    }
                }
            }
            
            // Draw moving cells in their respective colors
            movingCells.forEach(cell => {
                // Only draw moving cells in visible viewport
                if (cell.x >= viewOffsetX && cell.x < viewOffsetX + cellsVisibleX &&
                    cell.y >= viewOffsetY && cell.y < viewOffsetY + cellsVisibleY) {
                    
                    const color = cell.color || 1; // Default to white if no color specified
                    ctx.fillStyle = COLORS[color];
                    const screenX = (cell.x - viewOffsetX) * effectiveCellSize;
                    const screenY = (cell.y - viewOffsetY) * effectiveCellSize;
                    ctx.fillRect(screenX, screenY, effectiveCellSize, effectiveCellSize);
                }
            });
            
            // Draw line tool preview if active and start point is set
            if (lineToolActive && lineStartPoint && previewLineEnd) {
                ctx.strokeStyle = '#ff0000'; // Red line
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                const startScreenX = (lineStartPoint.x - viewOffsetX) * effectiveCellSize + effectiveCellSize / 2;
                const startScreenY = (lineStartPoint.y - viewOffsetY) * effectiveCellSize + effectiveCellSize / 2;
                const endScreenX = (previewLineEnd.x - viewOffsetX) * effectiveCellSize + effectiveCellSize / 2;
                const endScreenY = (previewLineEnd.y - viewOffsetY) * effectiveCellSize + effectiveCellSize / 2;
                
                ctx.moveTo(startScreenX, startScreenY);
                ctx.lineTo(endScreenX, endScreenY);
                ctx.stroke();
            }
            
            // Draw rectangle tool preview
            if (rectangleToolActive && rectangleStartPoint && previewRectangleEnd) {
                ctx.strokeStyle = '#ff0000'; // Red outline
                ctx.lineWidth = 1;
                
                const startScreenX = (rectangleStartPoint.x - viewOffsetX) * effectiveCellSize;
                const startScreenY = (rectangleStartPoint.y - viewOffsetY) * effectiveCellSize;
                const endScreenX = (previewRectangleEnd.x - viewOffsetX) * effectiveCellSize + effectiveCellSize;
                const endScreenY = (previewRectangleEnd.y - viewOffsetY) * effectiveCellSize + effectiveCellSize;
                
                ctx.strokeRect(startScreenX, startScreenY, endScreenX - startScreenX, endScreenY - startScreenY);
            }
            
            // Draw oval tool preview
            if (ovalToolActive && ovalStartPoint && previewOvalEnd) {
                ctx.strokeStyle = '#ff0000'; // Red outline
                ctx.lineWidth = 1;
                
                const centerScreenX = ((ovalStartPoint.x + previewOvalEnd.x) / 2 - viewOffsetX) * effectiveCellSize + effectiveCellSize / 2;
                const centerScreenY = ((ovalStartPoint.y + previewOvalEnd.y) / 2 - viewOffsetY) * effectiveCellSize + effectiveCellSize / 2;
                const radiusX = Math.abs(previewOvalEnd.x - ovalStartPoint.x) * effectiveCellSize / 2 + effectiveCellSize / 2;
                const radiusY = Math.abs(previewOvalEnd.y - ovalStartPoint.y) * effectiveCellSize / 2 + effectiveCellSize / 2;
                
                ctx.beginPath();
                ctx.ellipse(centerScreenX, centerScreenY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Draw eraser cursor - circle with red outline matching current eraser size
            if (eraserMode && eraserCursorPos && eraserSize > 0) {
                // Center of cursor is at the grid cell position
                const centerScreenX = (eraserCursorPos.x - viewOffsetX) * effectiveCellSize + effectiveCellSize / 2;
                const centerScreenY = (eraserCursorPos.y - viewOffsetY) * effectiveCellSize + effectiveCellSize / 2;
                
                // Radius based on eraser size: 1=2.5 cells, 2=12.5 cells, 3=25.5 cells
                let radius;
                if (eraserSize === 1) {
                    radius = 2.5 * effectiveCellSize;
                } else if (eraserSize === 2) {
                    radius = 12.5 * effectiveCellSize;
                } else if (eraserSize === 3) {
                    radius = 25.5 * effectiveCellSize;
                }
                
                // If actively erasing, draw filled red circle
                if (eraserActive) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; // Semi-transparent red fill
                    ctx.beginPath();
                    ctx.arc(centerScreenX, centerScreenY, radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Always draw the outline
                ctx.strokeStyle = '#ff0000'; // Red outline
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerScreenX, centerScreenY, radius, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            updateStats();
        }
        
        // Count neighbors of specific color (ignoring moving cells)
        function countNeighbors(x, y, targetColor) {
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                        if (grid[ny][nx] === targetColor) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }
        
        // Bresenham's line algorithm
        function drawLine(x0, y0, x1, y1, color) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                // Draw point
                if (x0 >= 0 && x0 < GRID_WIDTH && y0 >= 0 && y0 < GRID_HEIGHT) {
                    grid[y0][x0] = color;
                }
                
                if (x0 === x1 && y0 === y1) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }
        
        // Helper function to draw cells between two points (for smooth continuous drawing)
        // Simply draws the color without toggling
        function drawCellsBetween(x0, y0, x1, y1, color) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                // Simply draw the color at each point
                if (x0 >= 0 && x0 < GRID_WIDTH && y0 >= 0 && y0 < GRID_HEIGHT) {
                    grid[y0][x0] = color;
                }
                
                if (x0 === x1 && y0 === y1) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }
        
        // Helper function to erase cells between two points (for smooth continuous erasing)
        function eraseCellsBetween(x0, y0, x1, y1) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                // Erase at each point along the line
                if (x0 >= 0 && x0 < GRID_WIDTH && y0 >= 0 && y0 < GRID_HEIGHT) {
                    eraseCircularArea(x0, y0);
                }
                
                if (x0 === x1 && y0 === y1) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }
        
        // Draw rectangle outline (not filled)
        function drawRectangle(x0, y0, x1, y1, color) {
            const minX = Math.min(x0, x1);
            const maxX = Math.max(x0, x1);
            const minY = Math.min(y0, y1);
            const maxY = Math.max(y0, y1);
            
            // Draw top and bottom edges
            for (let x = minX; x <= maxX; x++) {
                if (x >= 0 && x < GRID_WIDTH) {
                    if (minY >= 0 && minY < GRID_HEIGHT) {
                        grid[minY][x] = color;
                    }
                    if (maxY >= 0 && maxY < GRID_HEIGHT) {
                        grid[maxY][x] = color;
                    }
                }
            }
            
            // Draw left and right edges
            for (let y = minY; y <= maxY; y++) {
                if (y >= 0 && y < GRID_HEIGHT) {
                    if (minX >= 0 && minX < GRID_WIDTH) {
                        grid[y][minX] = color;
                    }
                    if (maxX >= 0 && maxX < GRID_WIDTH) {
                        grid[y][maxX] = color;
                    }
                }
            }
        }
        
        // Draw oval outline (not filled) using midpoint ellipse algorithm
        function drawOval(x0, y0, x1, y1, color) {
            const centerX = Math.floor((x0 + x1) / 2);
            const centerY = Math.floor((y0 + y1) / 2);
            const radiusX = Math.floor(Math.abs(x1 - x0) / 2);
            const radiusY = Math.floor(Math.abs(y1 - y0) / 2);
            
            if (radiusX === 0 && radiusY === 0) {
                // Just a point
                if (centerX >= 0 && centerX < GRID_WIDTH && centerY >= 0 && centerY < GRID_HEIGHT) {
                    grid[centerY][centerX] = color;
                }
                return;
            }
            
            // Midpoint ellipse algorithm to draw outline
            let x = 0;
            let y = radiusY;
            
            // Region 1
            let d1 = (radiusY * radiusY) - (radiusX * radiusX * radiusY) + (0.25 * radiusX * radiusX);
            let dx = 2 * radiusY * radiusY * x;
            let dy = 2 * radiusX * radiusX * y;
            
            // Plot initial points in all four quadrants
            const plotEllipsePoints = (cx, cy, x, y) => {
                const points = [
                    {x: cx + x, y: cy + y},
                    {x: cx - x, y: cy + y},
                    {x: cx + x, y: cy - y},
                    {x: cx - x, y: cy - y}
                ];
                points.forEach(p => {
                    if (p.x >= 0 && p.x < GRID_WIDTH && p.y >= 0 && p.y < GRID_HEIGHT) {
                        grid[p.y][p.x] = color;
                    }
                });
            };
            
            // Region 1
            while (dx < dy) {
                plotEllipsePoints(centerX, centerY, x, y);
                
                if (d1 < 0) {
                    x++;
                    dx = dx + (2 * radiusY * radiusY);
                    d1 = d1 + dx + (radiusY * radiusY);
                } else {
                    x++;
                    y--;
                    dx = dx + (2 * radiusY * radiusY);
                    dy = dy - (2 * radiusX * radiusX);
                    d1 = d1 + dx - dy + (radiusY * radiusY);
                }
            }
            
            // Region 2
            let d2 = ((radiusY * radiusY) * ((x + 0.5) * (x + 0.5))) + ((radiusX * radiusX) * ((y - 1) * (y - 1))) - (radiusX * radiusX * radiusY * radiusY);
            
            while (y >= 0) {
                plotEllipsePoints(centerX, centerY, x, y);
                
                if (d2 > 0) {
                    y--;
                    dy = dy - (2 * radiusX * radiusX);
                    d2 = d2 + (radiusX * radiusX) - dy;
                } else {
                    y--;
                    x++;
                    dx = dx + (2 * radiusY * radiusY);
                    dy = dy - (2 * radiusX * radiusX);
                    d2 = d2 + dx - dy + (radiusX * radiusX);
                }
            }
        }
        
        // Find all connected cells of the same color (flood fill)
        function findConnectedGroup(startX, startY, targetColor, visited = null) {
            if (visited === null) {
                visited = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(false));
            }
            
            const group = [];
            const queue = [{x: startX, y: startY}];
            visited[startY][startX] = true;
            
            while (queue.length > 0) {
                const {x, y} = queue.shift();
                group.push({x, y});
                
                // Check all 8 neighbors
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                            if (!visited[ny][nx] && grid[ny][nx] === targetColor) {
                                visited[ny][nx] = true;
                                queue.push({x: nx, y: ny});
                            }
                        }
                    }
                }
            }
            
            return group;
        }
        
        // Check if there are any moving white cells in neighboring positions
        function hasMovingWhiteNeighbor(x, y) {
            for (let movingCell of movingCells) {
                const dx = Math.abs(movingCell.x - x);
                const dy = Math.abs(movingCell.y - y);
                if (dx <= 1 && dy <= 1 && !(dx === 0 && dy === 0)) {
                    return true;
                }
            }
            return false;
        }
        
        // Update grid for next generation
        function updateGrid() {
            const newGrid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
            const newStagnationTimers = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
            const newMovingCells = [];
            
            // Process moving white cells first
            movingCells.forEach(movingCell => {
                let {x, y, dx, dy, color, age} = movingCell;
                const movingColor = color || 1; // Default to white if no color specified
                const cellAge = age || 0; // Track how many frames this cell has been moving
                
                // Check if current position has stationary cell of same color - if so, stop moving
                if (grid[y][x] === movingColor) {
                    return; // This moving cell stops and becomes part of the stationary population
                }
                
                // PRIORITY 1: Check if neighboring any colored cells (not same color, not empty) - only if age > 3
                if (cellAge > 3) {
                    let otherColorNeighbor = null;
                    for (let dy2 = -1; dy2 <= 1; dy2++) {
                        for (let dx2 = -1; dx2 <= 1; dx2++) {
                            if (dx2 === 0 && dy2 === 0) continue;
                            const nx = x + dx2;
                            const ny = y + dy2;
                            if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                const neighborCell = grid[ny][nx];
                                // If neighbor is any color except same color or empty
                                if (neighborCell >= 1 && neighborCell <= 9 && neighborCell !== movingColor) {
                                    otherColorNeighbor = {x: nx, y: ny, color: neighborCell};
                                    break;
                                }
                            }
                        }
                        if (otherColorNeighbor) break;
                    }
                    
                    if (otherColorNeighbor) {
                        // Find entire connected group of this color
                        const group = findConnectedGroup(otherColorNeighbor.x, otherColorNeighbor.y, otherColorNeighbor.color);
                        
                        // Convert entire group to moving cell's color
                        group.forEach(cell => {
                            newGrid[cell.y][cell.x] = movingColor;
                            newStagnationTimers[cell.y][cell.x] = 0;
                        });
                        
                        // Stop moving and become stationary at current position
                        newGrid[y][x] = movingColor;
                        newStagnationTimers[y][x] = 0;
                        return;
                    }
                }
                
                // PRIORITY 2: Check if neighboring any stationary cells of SAME color - only if age > 3
                if (cellAge > 3) {
                    let hasSameColorNeighbor = false;
                    for (let dy2 = -1; dy2 <= 1; dy2++) {
                        for (let dx2 = -1; dx2 <= 1; dx2++) {
                            if (dx2 === 0 && dy2 === 0) continue;
                            const nx = x + dx2;
                            const ny = y + dy2;
                            if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                if (grid[ny][nx] === movingColor) {
                                    hasSameColorNeighbor = true;
                                    break;
                                }
                            }
                        }
                        if (hasSameColorNeighbor) break;
                    }
                    
                    if (hasSameColorNeighbor) {
                        // Stop moving and become stationary at current position
                        newGrid[y][x] = movingColor;
                        newStagnationTimers[y][x] = 0;
                        return;
                    }
                }
                
                // Random direction change (30% chance) - rotate by 1/8th (45 degrees)
                if (Math.random() < 0.3) {
                    // Define the 8 directions in clockwise order
                    const directions = [
                        {dx: 0, dy: -1},   // North
                        {dx: 1, dy: -1},   // Northeast
                        {dx: 1, dy: 0},    // East
                        {dx: 1, dy: 1},    // Southeast
                        {dx: 0, dy: 1},    // South
                        {dx: -1, dy: 1},   // Southwest
                        {dx: -1, dy: 0},   // West
                        {dx: -1, dy: -1}   // Northwest
                    ];
                    
                    // Find current direction index
                    let currentIndex = 0;
                    for (let i = 0; i < directions.length; i++) {
                        if (directions[i].dx === dx && directions[i].dy === dy) {
                            currentIndex = i;
                            break;
                        }
                    }
                    
                    // Rotate clockwise or counter-clockwise by 1 position (45 degrees)
                    const rotateClockwise = Math.random() < 0.5;
                    const newIndex = rotateClockwise 
                        ? (currentIndex + 1) % directions.length 
                        : (currentIndex - 1 + directions.length) % directions.length;
                    
                    dx = directions[newIndex].dx;
                    dy = directions[newIndex].dy;
                }
                
                // Calculate new position
                let newX = x + dx;
                let newY = y + dy;
                
                // Bounce off walls
                if (newX < 0 || newX >= GRID_WIDTH) {
                    dx = -dx;
                    newX = x + dx;
                }
                if (newY < 0 || newY >= GRID_HEIGHT) {
                    dy = -dy;
                    newY = y + dy;
                }
                
                // Check if new position has stationary cell of same color - if so, stop
                if (grid[newY][newX] === movingColor) {
                    // Moving cell stops at current position, becomes stationary
                    newGrid[y][x] = movingColor;
                    newStagnationTimers[y][x] = 0;
                    return;
                }
                
                // Check if new position neighbors stationary cells of same color - only if age > 3
                if (cellAge > 3) {
                    let hasSameColorNeighbor = false;
                    for (let dy2 = -1; dy2 <= 1; dy2++) {
                        for (let dx2 = -1; dx2 <= 1; dx2++) {
                            if (dx2 === 0 && dy2 === 0) continue;
                            const nx = newX + dx2;
                            const ny = newY + dy2;
                            if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                if (grid[ny][nx] === movingColor) {
                                    hasSameColorNeighbor = true;
                                    break;
                                }
                            }
                        }
                        if (hasSameColorNeighbor) break;
                    }
                    
                    if (hasSameColorNeighbor) {
                        // Stop moving and become stationary at current position (before moving)
                        newGrid[y][x] = movingColor;
                        newStagnationTimers[y][x] = 0;
                        return;
                    }
                }
                
                // Check if new position neighbors any cells of different color - only if age > 3
                if (cellAge > 3) {
                    let otherColorNeighbor = null;
                    for (let dy2 = -1; dy2 <= 1; dy2++) {
                        for (let dx2 = -1; dx2 <= 1; dx2++) {
                            if (dx2 === 0 && dy2 === 0) continue;
                            const nx = newX + dx2;
                            const ny = newY + dy2;
                            if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                const neighborCell = grid[ny][nx];
                                // If neighbor is any color except same color or empty
                                if (neighborCell >= 1 && neighborCell <= 9 && neighborCell !== movingColor) {
                                    otherColorNeighbor = {x: nx, y: ny, color: neighborCell};
                                    break;
                                }
                            }
                        }
                        if (otherColorNeighbor) break;
                    }
                    
                    if (otherColorNeighbor) {
                        // Find entire connected group of this color
                        const group = findConnectedGroup(otherColorNeighbor.x, otherColorNeighbor.y, otherColorNeighbor.color);
                        
                        // Convert entire group to moving cell's color
                        group.forEach(cell => {
                            newGrid[cell.y][cell.x] = movingColor;
                            newStagnationTimers[cell.y][cell.x] = 0;
                        });
                        
                        // Move to new position and become stationary
                        newGrid[newY][newX] = movingColor;
                        newStagnationTimers[newY][newX] = 0;
                        return;
                    }
                }
                
                // If new position is empty or has another moving cell, continue moving
                if (grid[newY][newX] === CELL_EMPTY || grid[newY][newX] === CELL_WHITE_MOVING) {
                    newMovingCells.push({x: newX, y: newY, dx, dy, color: movingColor, age: cellAge + 1});
                } else {
                    // Hit another obstacle, stop and become stationary at current position
                    newGrid[y][x] = movingColor;
                    newStagnationTimers[y][x] = 0;
                }
            });
            
            // Process regular cells
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    // Skip if this cell was already processed by moving white cells
                    if (newGrid[y][x] !== 0) {
                        continue;
                    }
                    
                    const cell = grid[y][x];
                    
                    if (cell === CELL_EMPTY) {
                        // Check for birth (adjustable neighbor range)
                        for (let color = 1; color <= 9; color++) {
                            const colorNeighbors = countNeighbors(x, y, color);
                            if (colorNeighbors >= BIRTH_MIN_NEIGHBORS && colorNeighbors <= BIRTH_MAX_NEIGHBORS) {
                                newGrid[y][x] = color;
                                newStagnationTimers[y][x] = 0;
                                break;
                            }
                        }
                    } else if (cell >= 1 && cell <= 9) {
                        const neighbors = countNeighbors(x, y, cell);
                        
                        // Magenta special case: evolution range neighbors
                        if (cell === 9 && neighbors >= EVOLUTION_MIN_NEIGHBORS && neighbors <= EVOLUTION_MAX_NEIGHBORS) {
                            if (movingCellsEnabled) {
                                // Moving cells enabled: spawn moving white and die
                                newGrid[y][x] = CELL_EMPTY;
                                newStagnationTimers[y][x] = 0;
                                
                                // Spawn one moving white cell in random empty neighbor
                                const emptyNeighbors = [];
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        if (dx === 0 && dy === 0) continue;
                                        const nx = x + dx;
                                        const ny = y + dy;
                                        if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                            if (grid[ny][nx] === CELL_EMPTY) {
                                                emptyNeighbors.push({x: nx, y: ny, dx, dy});
                                            }
                                        }
                                    }
                                }
                                
                                if (emptyNeighbors.length > 0) {
                                    const spawn = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                                    newMovingCells.push({...spawn, color: 1, age: 0}); // White moving cell with age 0
                                }
                            } else {
                                // Moving cells disabled: evolve to white
                                newGrid[y][x] = 1; // White
                                newStagnationTimers[y][x] = 0;
                            }
                        }
                        // Survival: adjustable neighbor range
                        else if (neighbors >= SURVIVAL_MIN_NEIGHBORS && neighbors <= SURVIVAL_MAX_NEIGHBORS) {
                            newGrid[y][x] = cell;
                            newStagnationTimers[y][x] = stagnationTimers[y][x] + 1;
                        }
                        // Evolution: evolve to next color based on adjustable neighbor range
                        else if (neighbors >= EVOLUTION_MIN_NEIGHBORS && neighbors <= EVOLUTION_MAX_NEIGHBORS && cell < 9) {
                            newGrid[y][x] = cell + 1;
                            newStagnationTimers[y][x] = 0;
                        }
                        else if (neighbors >= EVOLUTION_MIN_NEIGHBORS && neighbors <= EVOLUTION_MAX_NEIGHBORS && cell === 9 && !movingCellsEnabled) {
                            // Magenta evolves to white when moving cells disabled
                            newGrid[y][x] = 1; // White
                            newStagnationTimers[y][x] = 0;
                        }
                        // Otherwise: die
                        else {
                            newGrid[y][x] = CELL_EMPTY;
                            newStagnationTimers[y][x] = 0;
                        }
                    }
                }
            }
            
            // Apply stagnation conversion: check cells that haven't changed in 100 frames
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = newGrid[y][x];
                    
                    // Any colored cell (including white) with 3+ neighbors of same color spawns moving cell after Color Expansion Rate
                    // Only if moving cells are enabled
                    if (movingCellsEnabled && cell >= 1 && cell <= 9 && newStagnationTimers[y][x] >= COLOR_EXPANSION_RATE) {
                        const sameColorNeighbors = countNeighbors(x, y, cell);
                        if (sameColorNeighbors >= 3) {
                            // Find an empty neighbor to spawn the moving cell
                            const emptyNeighbors = [];
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                        if (newGrid[ny][nx] === CELL_EMPTY) {
                                            emptyNeighbors.push({x: nx, y: ny, dx, dy});
                                        }
                                    }
                                }
                            }
                            
                            if (emptyNeighbors.length > 0) {
                                const spawn = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                                // Store the color with the moving cell, age starts at 0
                                newMovingCells.push({...spawn, color: cell, age: 0});
                                newStagnationTimers[y][x] = 0; // Reset timer after spawning
                            }
                        }
                    }
                    
                    // Colored cells (not white) that are stagnant do color conversion if Neighbors Fight is enabled
                    if (neighborsFightEnabled && cell >= 2 && cell <= 9 && newStagnationTimers[y][x] >= COLOR_EXPANSION_RATE) {
                        // Check all neighbors
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                    const neighborCell = newGrid[ny][nx];
                                    // If neighbor is a lower color (higher number = higher in hierarchy)
                                    if (neighborCell >= 1 && neighborCell <= 9 && neighborCell < cell) {
                                        // Convert neighbor to match this cell's color
                                        newGrid[ny][nx] = cell;
                                        newStagnationTimers[ny][nx] = 0; // Reset timer for converted cell
                                    }
                                }
                            }
                        }
                        // Reset the stagnation timer after conversion attempt
                        newStagnationTimers[y][x] = 0;
                    }
                }
            }
            
            grid = newGrid;
            stagnationTimers = newStagnationTimers;
            movingCells = newMovingCells;
            generation++;
        }
        
        // Update statistics
        function updateStats() {
            document.getElementById('generation').textContent = generation;
            document.getElementById('zoomDisplay').textContent = zoomLevel.toFixed(2) + 'x';
        }
        
        // Game loop
        function gameLoop(timestamp) {
            if (isPlaying) {
                if (timestamp - lastUpdate > 1000 / SPEED) {
                    updateGrid();
                    drawGrid();
                    lastUpdate = timestamp;
                }
                requestAnimationFrame(gameLoop);
            }
        }
        
        // Clear grid
        function clearGrid() {
            initGrid();
            generation = 0;
            drawGrid();
        }
        
        // Random grid
        function randomGrid() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    grid[y][x] = Math.random() > 0.85 ? 1 : 0;
                }
            }
            generation = 0;
            drawGrid();
        }
        
        
        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            // Skip right-click
            if (e.button === 2) {
                e.preventDefault();
                return;
            }
            
            if (e.button !== 0) return; // Only process left clicks
            
            const rect = canvas.getBoundingClientRect();
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            const x = Math.floor(viewOffsetX + (e.clientX - rect.left) / effectiveCellSize);
            const y = Math.floor(viewOffsetY + (e.clientY - rect.top) / effectiveCellSize);
            
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                if (zoomMode === 1) {
                    // Zoom in mode
                    zoomLevel = Math.min(10, zoomLevel + 1);
                    
                    // Center view on clicked cell
                    const cellsVisibleX = Math.ceil(GRID_WIDTH / zoomLevel);
                    const cellsVisibleY = Math.ceil(GRID_HEIGHT / zoomLevel);
                    
                    viewOffsetX = Math.floor(x - cellsVisibleX / 2);
                    viewOffsetY = Math.floor(y - cellsVisibleY / 2);
                    
                    drawGrid();
                } else if (zoomMode === 2) {
                    // Zoom out mode - minimum zoom is 1.0 to prevent showing black space
                    if (zoomLevel > 1.0) {
                        const gridX = x;
                        const gridY = y;
                        
                        zoomLevel = Math.max(1.0, zoomLevel - 1);
                        
                        // Recenter view on the clicked position
                        const cellsVisibleX = Math.ceil(GRID_WIDTH / zoomLevel);
                        const cellsVisibleY = Math.ceil(GRID_HEIGHT / zoomLevel);
                        
                        viewOffsetX = Math.floor(gridX - cellsVisibleX / 2);
                        viewOffsetY = Math.floor(gridY - cellsVisibleY / 2);
                        
                        drawGrid();
                    }
                } else {
                    // Normal drawing mode or shape tool modes
                    if (lineToolActive) {
                        // Line tool mode
                        if (!lineStartPoint) {
                            lineStartPoint = {x, y};
                            previewLineEnd = {x, y};
                        } else {
                            drawLine(lineStartPoint.x, lineStartPoint.y, x, y, selectedColor);
                            lineStartPoint = null;
                            previewLineEnd = null;
                            drawGrid();
                        }
                    } else if (rectangleToolActive) {
                        // Rectangle tool mode
                        if (!rectangleStartPoint) {
                            rectangleStartPoint = {x, y};
                            previewRectangleEnd = {x, y};
                        } else {
                            drawRectangle(rectangleStartPoint.x, rectangleStartPoint.y, x, y, selectedColor);
                            rectangleStartPoint = null;
                            previewRectangleEnd = null;
                            drawGrid();
                        }
                    } else if (ovalToolActive) {
                        // Oval tool mode
                        if (!ovalStartPoint) {
                            ovalStartPoint = {x, y};
                            previewOvalEnd = {x, y};
                        } else {
                            drawOval(ovalStartPoint.x, ovalStartPoint.y, x, y, selectedColor);
                            ovalStartPoint = null;
                            previewOvalEnd = null;
                            drawGrid();
                        }
                    } else {
                        // Normal drawing mode
                        mouseDown = true;
                        if (eraserMode) {
                            eraserActive = true;
                            eraseCircularArea(x, y);
                        } else {
                            // Draw with selected color directly (no toggle)
                            grid[y][x] = selectedColor;
                        }
                        lastCell = {x, y};
                        drawGrid();
                    }
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!mouseDown || zoomMode !== 0 || lineToolActive || rectangleToolActive || ovalToolActive) return;
            const rect = canvas.getBoundingClientRect();
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            const x = Math.floor(viewOffsetX + (e.clientX - rect.left) / effectiveCellSize);
            const y = Math.floor(viewOffsetY + (e.clientY - rect.top) / effectiveCellSize);
            
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                if (!lastCell || lastCell.x !== x || lastCell.y !== y) {
                    if (eraserMode) {
                        eraserActive = true;
                        // Interpolate eraser between last position and current position
                        if (lastCell) {
                            eraseCellsBetween(lastCell.x, lastCell.y, x, y);
                        } else {
                            eraseCircularArea(x, y);
                        }
                    } else {
                        // Interpolate drawing between last position and current position
                        if (lastCell) {
                            drawCellsBetween(lastCell.x, lastCell.y, x, y, selectedColor);
                        } else {
                            // First cell
                            grid[y][x] = selectedColor;
                        }
                    }
                    lastCell = {x, y};
                    drawGrid();
                }
            }
        });
        
        // Separate mousemove handlers for shape tool previews
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            const x = Math.floor(viewOffsetX + (e.clientX - rect.left) / effectiveCellSize);
            const y = Math.floor(viewOffsetY + (e.clientY - rect.top) / effectiveCellSize);
            
            // Track eraser cursor position
            if (eraserMode && x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                eraserCursorPos = {x, y};
                canvas.classList.add('eraser-cursor');
                drawGrid();
            } else if (eraserMode) {
                eraserCursorPos = null;
                canvas.classList.add('eraser-cursor');
            } else {
                eraserCursorPos = null;
                canvas.classList.remove('eraser-cursor');
            }
            
            if (lineToolActive && lineStartPoint) {
                if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                    previewLineEnd = {x, y};
                    drawGrid();
                }
            } else if (rectangleToolActive && rectangleStartPoint) {
                if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                    previewRectangleEnd = {x, y};
                    drawGrid();
                }
            } else if (ovalToolActive && ovalStartPoint) {
                if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                    previewOvalEnd = {x, y};
                    drawGrid();
                }
            }
        });
        
        // Clear eraser cursor when mouse leaves canvas
        canvas.addEventListener('mouseleave', () => {
            eraserCursorPos = null;
            canvas.classList.remove('eraser-cursor');
            mouseDown = false;
            lastCell = null;
            if (eraserActive) {
                eraserActive = false;
            }
            if (eraserMode) {
                drawGrid(); // Redraw to remove cursor
            }
        });
        
        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Touch events for mobile support
        let lastTouchCell = null;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling while drawing
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            const x = Math.floor(viewOffsetX + (touch.clientX - rect.left) / effectiveCellSize);
            const y = Math.floor(viewOffsetY + (touch.clientY - rect.top) / effectiveCellSize);
            
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                if (zoomMode === 1) {
                    // Zoom in mode
                    zoomLevel = Math.min(10, zoomLevel + 1);
                    
                    // Center view on clicked cell
                    const cellsVisibleX = Math.ceil(GRID_WIDTH / zoomLevel);
                    const cellsVisibleY = Math.ceil(GRID_HEIGHT / zoomLevel);
                    
                    viewOffsetX = Math.floor(x - cellsVisibleX / 2);
                    viewOffsetY = Math.floor(y - cellsVisibleY / 2);
                    
                    drawGrid();
                } else if (zoomMode === 2) {
                    // Zoom out mode - minimum zoom is 1.0 to prevent showing black space
                    if (zoomLevel > 1.0) {
                        const gridX = x;
                        const gridY = y;
                        
                        zoomLevel = Math.max(1.0, zoomLevel - 1);
                        
                        // Recenter view on the clicked position
                        const cellsVisibleX = Math.ceil(GRID_WIDTH / zoomLevel);
                        const cellsVisibleY = Math.ceil(GRID_HEIGHT / zoomLevel);
                        
                        viewOffsetX = Math.floor(gridX - cellsVisibleX / 2);
                        viewOffsetY = Math.floor(gridY - cellsVisibleY / 2);
                        
                        drawGrid();
                    }
                } else {
                    // Normal drawing mode or shape tool modes
                    if (lineToolActive) {
                        // Line tool mode
                        if (!lineStartPoint) {
                            lineStartPoint = {x, y};
                        } else {
                            drawLine(lineStartPoint.x, lineStartPoint.y, x, y, selectedColor);
                            lineStartPoint = null;
                            drawGrid();
                        }
                    } else if (rectangleToolActive) {
                        // Rectangle tool mode
                        if (!rectangleStartPoint) {
                            rectangleStartPoint = {x, y};
                        } else {
                            drawRectangle(rectangleStartPoint.x, rectangleStartPoint.y, x, y, selectedColor);
                            rectangleStartPoint = null;
                            drawGrid();
                        }
                    } else if (ovalToolActive) {
                        // Oval tool mode
                        if (!ovalStartPoint) {
                            ovalStartPoint = {x, y};
                        } else {
                            drawOval(ovalStartPoint.x, ovalStartPoint.y, x, y, selectedColor);
                            ovalStartPoint = null;
                            drawGrid();
                        }
                    } else {
                        // Normal drawing mode
                        if (eraserMode) {
                            eraserActive = true;
                            eraserCursorPos = {x, y}; // Set cursor position for visual feedback
                            eraseCircularArea(x, y);
                        } else {
                            // Draw with selected color directly (no toggle)
                            grid[y][x] = selectedColor;
                        }
                        lastTouchCell = {x, y};
                        drawGrid();
                    }
                }
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (zoomMode !== 0 || lineToolActive || rectangleToolActive || ovalToolActive) return;
            e.preventDefault(); // Prevent scrolling while drawing
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const effectiveCellSize = CELL_SIZE * zoomLevel;
            const x = Math.floor(viewOffsetX + (touch.clientX - rect.left) / effectiveCellSize);
            const y = Math.floor(viewOffsetY + (touch.clientY - rect.top) / effectiveCellSize);
            
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                if (!lastTouchCell || lastTouchCell.x !== x || lastTouchCell.y !== y) {
                    if (eraserMode) {
                        eraserActive = true;
                        eraserCursorPos = {x, y}; // Set cursor position for visual feedback
                        // Interpolate eraser between last position and current position
                        if (lastTouchCell) {
                            eraseCellsBetween(lastTouchCell.x, lastTouchCell.y, x, y);
                        } else {
                            eraseCircularArea(x, y);
                        }
                    } else {
                        // Interpolate drawing between last position and current position
                        if (lastTouchCell) {
                            drawCellsBetween(lastTouchCell.x, lastTouchCell.y, x, y, selectedColor);
                        } else {
                            // First cell
                            grid[y][x] = selectedColor;
                        }
                    }
                    lastTouchCell = {x, y};
                    drawGrid();
                }
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            lastTouchCell = null;
            if (eraserActive) {
                eraserActive = false;
                eraserCursorPos = null; // Clear cursor position
                drawGrid(); // Redraw to remove the filled circle
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
            lastCell = null;
            if (eraserActive) {
                eraserActive = false;
                drawGrid(); // Redraw to remove the filled circle
            }
        });
        
        // Control events
        document.getElementById('playPause').addEventListener('click', function() {
            deactivateZoom();
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
            if (isPlaying) {
                requestAnimationFrame(gameLoop);
            }
        });
        
        document.getElementById('step').addEventListener('click', () => {
            deactivateZoom();
            updateGrid();
            drawGrid();
        });
        
        document.getElementById('clear').addEventListener('click', () => {
            deactivateZoom();
            clearGrid();
        });
        
        document.getElementById('randomButton').addEventListener('click', () => {
            deactivateZoom();
            randomGrid();
        });
        
        document.getElementById('toggleNeighborsFight').addEventListener('click', function() {
            deactivateZoom();
            neighborsFightEnabled = !neighborsFightEnabled;
            this.textContent = neighborsFightEnabled ? 'Neighbors Fight: ON' : 'Neighbors Fight: OFF';
            this.classList.toggle('active');
        });
        
        document.getElementById('toggleMovingCells').addEventListener('click', function() {
            deactivateZoom();
            movingCellsEnabled = !movingCellsEnabled;
            this.textContent = movingCellsEnabled ? 'Moving Cells: ON' : 'Moving Cells: OFF';
            this.classList.toggle('active');
            
            // Clear all existing moving cells when disabled
            if (!movingCellsEnabled) {
                movingCells = [];
                drawGrid();
            }
        });
        
        document.getElementById('colorExpansionRate').addEventListener('input', (e) => {
            deactivateZoom();
            COLOR_EXPANSION_RATE = parseInt(e.target.value);
            document.getElementById('colorExpansionValue').textContent = COLOR_EXPANSION_RATE;
        });
        
        document.getElementById('lineToolButton').addEventListener('click', function() {
            deactivateZoom();
            deactivateRectangleTool();
            deactivateOvalTool();
            deactivateEraser();
            lineToolActive = !lineToolActive;
            this.classList.toggle('active');
            
            if (!lineToolActive) {
                lineStartPoint = null;
                previewLineEnd = null;
                drawGrid();
            }
        });
        
        document.getElementById('rectangleToolButton').addEventListener('click', function() {
            deactivateZoom();
            deactivateLineTool();
            deactivateOvalTool();
            deactivateEraser();
            rectangleToolActive = !rectangleToolActive;
            this.classList.toggle('active');
            
            if (!rectangleToolActive) {
                rectangleStartPoint = null;
                previewRectangleEnd = null;
                drawGrid();
            }
        });
        
        document.getElementById('ovalToolButton').addEventListener('click', function() {
            deactivateZoom();
            deactivateLineTool();
            deactivateRectangleTool();
            deactivateEraser();
            ovalToolActive = !ovalToolActive;
            this.classList.toggle('active');
            
            if (!ovalToolActive) {
                ovalStartPoint = null;
                previewOvalEnd = null;
                drawGrid();
            }
        });
        
        document.getElementById('zoomButton').addEventListener('click', function() {
            deactivateEraser();
            zoomMode = (zoomMode + 1) % 3; // Cycle through 0, 1, 2
            
            if (zoomMode === 0) {
                this.textContent = 'Zoom: OFF';
                this.classList.remove('active');
            } else if (zoomMode === 1) {
                this.textContent = 'Zoom: IN';
                this.classList.add('active');
            } else if (zoomMode === 2) {
                this.textContent = 'Zoom: OUT';
                this.classList.add('active');
            }
        });
        
        // Function to deactivate zoom mode
        function deactivateZoom() {
            if (zoomMode !== 0) {
                zoomMode = 0;
                const zoomButton = document.getElementById('zoomButton');
                zoomButton.textContent = 'Zoom: OFF';
                zoomButton.classList.remove('active');
            }
        }
        
        // Calculate minimum zoom level to fit entire canvas
        function getMinZoomLevel() {
            // Minimum zoom is 1.0 - this ensures we never zoom out to show black space
            // beyond the canvas dimensions. At zoom level 1.0, the entire canvas is visible.
            return 1.0;
        }
        
        // Function to deactivate line tool
        function deactivateLineTool() {
            if (lineToolActive) {
                lineToolActive = false;
                lineStartPoint = null;
                previewLineEnd = null;
                const lineButton = document.getElementById('lineToolButton');
                lineButton.classList.remove('active');
                drawGrid(); // Redraw to clear preview line
            }
        }
        
        // Function to deactivate rectangle tool
        function deactivateRectangleTool() {
            if (rectangleToolActive) {
                rectangleToolActive = false;
                rectangleStartPoint = null;
                previewRectangleEnd = null;
                const rectButton = document.getElementById('rectangleToolButton');
                rectButton.classList.remove('active');
                drawGrid();
            }
        }
        
        // Function to deactivate oval tool
        function deactivateOvalTool() {
            if (ovalToolActive) {
                ovalToolActive = false;
                ovalStartPoint = null;
                previewOvalEnd = null;
                const ovalButton = document.getElementById('ovalToolButton');
                ovalButton.classList.remove('active');
                drawGrid();
            }
        }
        
        // Function to deactivate eraser
        function deactivateEraser() {
            if (eraserMode) {
                eraserMode = false;
                eraserSize = 0;
                eraserCursorPos = null;
                canvas.classList.remove('eraser-cursor');
                const eraserButton = document.getElementById('eraserButton');
                eraserButton.innerHTML = '<span style="font-size: 16px;">üóëÔ∏è</span> Eraser';
                eraserButton.classList.remove('active');
                drawGrid();
            }
        }
        
        // Color swatch selection
        document.querySelectorAll('.color-swatch').forEach(button => {
            button.addEventListener('click', function() {
                // Deactivate zoom and eraser when color is selected (but keep shape tools active)
                deactivateZoom();
                deactivateEraser();
                
                // Remove active class from all swatches
                document.querySelectorAll('.color-swatch').forEach(b => b.classList.remove('active'));
                // Add active class to clicked swatch
                this.classList.add('active');
                // Set selected color
                selectedColor = parseInt(this.getAttribute('data-color'));
                previousColor = selectedColor; // Update previous color
            });
        });
        
        // Eraser button (separate from color swatches)
        document.getElementById('eraserButton').addEventListener('click', function() {
            // Deactivate zoom and all drawing tools when eraser is clicked
            deactivateZoom();
            deactivateLineTool();
            deactivateRectangleTool();
            deactivateOvalTool();
            
            // Cycle through eraser sizes: 0 (off) -> 1 (5x5) -> 2 (25x25) -> 3 (51x51) -> 0 (off)
            eraserSize = (eraserSize + 1) % 4;
            
            if (eraserSize === 0) {
                // Deactivate eraser
                eraserMode = false;
                eraserCursorPos = null;
                canvas.classList.remove('eraser-cursor');
                this.classList.remove('active');
                this.innerHTML = '<span style="font-size: 16px;">üóëÔ∏è</span> Eraser';
                
                // Reactivate the previous color swatch
                const previousColorSwatch = document.querySelector(`.color-swatch[data-color="${previousColor}"]`);
                if (previousColorSwatch) {
                    previousColorSwatch.classList.add('active');
                }
                selectedColor = previousColor;
                drawGrid();
            } else {
                // Activate eraser with specific size
                if (!eraserMode) {
                    // First time activating eraser, save current color
                    previousColor = selectedColor;
                    eraserMode = true;
                    // Remove active from all color swatches
                    document.querySelectorAll('.color-swatch').forEach(b => b.classList.remove('active'));
                }
                
                this.classList.add('active');
                
                // Update button text based on size
                if (eraserSize === 1) {
                    this.innerHTML = '<span style="font-size: 16px;">üóëÔ∏è</span> Eraser (5x5)';
                } else if (eraserSize === 2) {
                    this.innerHTML = '<span style="font-size: 16px;">üóëÔ∏è</span> Eraser (25x25)';
                } else if (eraserSize === 3) {
                    this.innerHTML = '<span style="font-size: 16px;">üóëÔ∏è</span> Eraser (51x51)';
                }
            }
        });
        
        document.getElementById('speed').addEventListener('input', (e) => {
            SPEED = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = SPEED;
        });
        
        // Birth rule sliders
        document.getElementById('birthMin').addEventListener('input', (e) => {
            deactivateZoom();
            let newMin = parseInt(e.target.value);
            if (newMin > BIRTH_MAX_NEIGHBORS) {
                newMin = BIRTH_MAX_NEIGHBORS;
                e.target.value = newMin;
                
                // Highlight the max value that's capping us
                const birthMaxValue = document.getElementById('birthMaxValue');
                birthMaxValue.classList.add('capped-highlight');
                setTimeout(() => {
                    birthMaxValue.classList.remove('capped-highlight');
                }, 500);
            }
            BIRTH_MIN_NEIGHBORS = newMin;
            document.getElementById('birthMinValue').textContent = newMin;
        });
        
        document.getElementById('birthMax').addEventListener('input', (e) => {
            deactivateZoom();
            let newMax = parseInt(e.target.value);
            if (newMax < BIRTH_MIN_NEIGHBORS) {
                newMax = BIRTH_MIN_NEIGHBORS;
                e.target.value = newMax;
                
                // Highlight the min value that's capping us
                const birthMinValue = document.getElementById('birthMinValue');
                birthMinValue.classList.add('capped-highlight');
                setTimeout(() => {
                    birthMinValue.classList.remove('capped-highlight');
                }, 500);
            }
            BIRTH_MAX_NEIGHBORS = newMax;
            document.getElementById('birthMaxValue').textContent = newMax;
        });
        
        // Survival rule sliders
        document.getElementById('survivalMin').addEventListener('input', (e) => {
            deactivateZoom();
            let newMin = parseInt(e.target.value);
            if (newMin > SURVIVAL_MAX_NEIGHBORS) {
                newMin = SURVIVAL_MAX_NEIGHBORS;
                e.target.value = newMin;
                
                // Highlight the max value that's capping us
                const survivalMaxValue = document.getElementById('survivalMaxValue');
                survivalMaxValue.classList.add('capped-highlight');
                setTimeout(() => {
                    survivalMaxValue.classList.remove('capped-highlight');
                }, 500);
            }
            SURVIVAL_MIN_NEIGHBORS = newMin;
            document.getElementById('survivalMinValue').textContent = newMin;
        });
        
        document.getElementById('survivalMax').addEventListener('input', (e) => {
            deactivateZoom();
            let newMax = parseInt(e.target.value);
            let wasCapped = false;
            
            if (newMax < SURVIVAL_MIN_NEIGHBORS) {
                newMax = SURVIVAL_MIN_NEIGHBORS;
                e.target.value = newMax;
                
                // Highlight the min value that's capping us
                const survivalMinValue = document.getElementById('survivalMinValue');
                survivalMinValue.classList.add('capped-highlight');
                setTimeout(() => {
                    survivalMinValue.classList.remove('capped-highlight');
                }, 500);
            }
            // Survival max cannot exceed death threshold
            if (newMax >= DEATH_MIN_NEIGHBORS) {
                newMax = DEATH_MIN_NEIGHBORS - 1;
                e.target.value = newMax;
                wasCapped = true;
                
                // Highlight the death value that's capping us
                const deathValue = document.getElementById('deathMinValue');
                deathValue.classList.add('capped-highlight');
                setTimeout(() => {
                    deathValue.classList.remove('capped-highlight');
                }, 500);
            }
            
            SURVIVAL_MAX_NEIGHBORS = newMax;
            document.getElementById('survivalMaxValue').textContent = newMax;
        });
        
        // Evolution rule sliders
        document.getElementById('evolutionMin').addEventListener('input', (e) => {
            deactivateZoom();
            let newMin = parseInt(e.target.value);
            if (newMin > EVOLUTION_MAX_NEIGHBORS) {
                newMin = EVOLUTION_MAX_NEIGHBORS;
                e.target.value = newMin;
                
                // Highlight the max value that's capping us
                const evolutionMaxValue = document.getElementById('evolutionMaxValue');
                evolutionMaxValue.classList.add('capped-highlight');
                setTimeout(() => {
                    evolutionMaxValue.classList.remove('capped-highlight');
                }, 500);
            }
            EVOLUTION_MIN_NEIGHBORS = newMin;
            document.getElementById('evolutionMinValue').textContent = newMin;
        });
        
        document.getElementById('evolutionMax').addEventListener('input', (e) => {
            deactivateZoom();
            let newMax = parseInt(e.target.value);
            if (newMax < EVOLUTION_MIN_NEIGHBORS) {
                newMax = EVOLUTION_MIN_NEIGHBORS;
                e.target.value = newMax;
                
                // Highlight the min value that's capping us
                const evolutionMinValue = document.getElementById('evolutionMinValue');
                evolutionMinValue.classList.add('capped-highlight');
                setTimeout(() => {
                    evolutionMinValue.classList.remove('capped-highlight');
                }, 500);
            }
            EVOLUTION_MAX_NEIGHBORS = newMax;
            document.getElementById('evolutionMaxValue').textContent = newMax;
            
            // Update death minimum to stay above evolution max
            if (DEATH_MIN_NEIGHBORS <= newMax) {
                DEATH_MIN_NEIGHBORS = newMax + 1;
                document.getElementById('deathMin').value = DEATH_MIN_NEIGHBORS;
                document.getElementById('deathMinValue').textContent = DEATH_MIN_NEIGHBORS;
            }
        });
        
        // Death rule slider
        document.getElementById('deathMin').addEventListener('input', (e) => {
            deactivateZoom();
            let newMin = parseInt(e.target.value);
            
            // Death must be above evolution max
            if (newMin <= EVOLUTION_MAX_NEIGHBORS) {
                newMin = EVOLUTION_MAX_NEIGHBORS + 1;
                e.target.value = newMin;
                
                // Highlight the evolution value that's capping us
                const evolutionValue = document.getElementById('evolutionMaxValue');
                evolutionValue.classList.add('capped-highlight');
                setTimeout(() => {
                    evolutionValue.classList.remove('capped-highlight');
                }, 500);
            }
            // Death must be above survival max
            else if (newMin <= SURVIVAL_MAX_NEIGHBORS) {
                newMin = SURVIVAL_MAX_NEIGHBORS + 1;
                e.target.value = newMin;
                
                // Highlight the survival value that's capping us
                const survivalValue = document.getElementById('survivalMaxValue');
                survivalValue.classList.add('capped-highlight');
                setTimeout(() => {
                    survivalValue.classList.remove('capped-highlight');
                }, 500);
            }
            
            DEATH_MIN_NEIGHBORS = newMin;
            document.getElementById('deathMinValue').textContent = newMin;
        });
        
        // Reset all rules to default values
        document.getElementById('resetRulesToDefault').addEventListener('click', function() {
            deactivateZoom();
            
            // Birth: 3-3
            BIRTH_MIN_NEIGHBORS = 3;
            BIRTH_MAX_NEIGHBORS = 3;
            document.getElementById('birthMin').value = 3;
            document.getElementById('birthMax').value = 3;
            document.getElementById('birthMinValue').textContent = 3;
            document.getElementById('birthMaxValue').textContent = 3;
            
            // Survival: 2-3
            SURVIVAL_MIN_NEIGHBORS = 2;
            SURVIVAL_MAX_NEIGHBORS = 3;
            document.getElementById('survivalMin').value = 2;
            document.getElementById('survivalMax').value = 3;
            document.getElementById('survivalMinValue').textContent = 2;
            document.getElementById('survivalMaxValue').textContent = 3;
            
            // Evolution: 4-4
            EVOLUTION_MIN_NEIGHBORS = 4;
            EVOLUTION_MAX_NEIGHBORS = 4;
            document.getElementById('evolutionMin').value = 4;
            document.getElementById('evolutionMax').value = 4;
            document.getElementById('evolutionMinValue').textContent = 4;
            document.getElementById('evolutionMaxValue').textContent = 4;
            
            // Death: 5+
            DEATH_MIN_NEIGHBORS = 5;
            document.getElementById('deathMin').value = 5;
            document.getElementById('deathMinValue').textContent = 5;
            
            // Color Expansion Rate: 100
            COLOR_EXPANSION_RATE = 100;
            document.getElementById('colorExpansionRate').value = 100;
            document.getElementById('colorExpansionValue').textContent = 100;
        });
        
        // Size preset buttons removed - mobile size is auto-detected
        
        document.getElementById('applyCanvasSize').addEventListener('click', function() {
            deactivateZoom();
            const newWidth = parseInt(document.getElementById('canvasWidth').value);
            const newHeight = parseInt(document.getElementById('canvasHeight').value);
            
            GRID_WIDTH = newWidth;
            GRID_HEIGHT = newHeight;
            
            // Reset zoom to 1 if current zoom is below new minimum
            const minZoom = getMinZoomLevel();
            if (zoomLevel < minZoom) {
                zoomLevel = 1;
                viewOffsetX = 0;
                viewOffsetY = 0;
            }
            
            initGrid();
            resizeCanvas();
            drawGrid();
        });
        
        // Detect mobile device and set canvas to 100x150
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                || (window.innerWidth <= 768);
        }
        
        // If mobile device, automatically set to mobile size
        if (isMobileDevice()) {
            GRID_WIDTH = 100;
            GRID_HEIGHT = 150;
            document.getElementById('canvasWidth').value = '100';
            document.getElementById('canvasHeight').value = '150';
        }
        
        // Initialize
        initGrid();
        resizeCanvas();
        drawGrid();
    </script>
</body>
</html>